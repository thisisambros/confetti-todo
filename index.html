<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Confetti Todo</title>
    <link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
    <h1>Confetti Todo</h1>
    
    <div class="app-layout">
        <div class="main-content">
            <!-- North Star Task -->
            <div class="north-star-section" id="north-star-section">
                <div class="north-star-icon">‚≠ê</div>
                <div class="north-star-content">
                    <div class="north-star-label">Today's North Star</div>
                    <div class="north-star-title" id="north-star-title"></div>
                    <div class="north-star-meta">
                        <span id="north-star-category"></span>
                        <span id="north-star-effort"></span>
                        <span class="north-star-xp" id="north-star-xp"></span>
                    </div>
                </div>
                <div class="north-star-actions">
                    <button class="work-btn" id="north-star-work" title="Work on this">‚ñ∂</button>
                    <button class="uncrown-btn" id="north-star-uncrown" title="Remove star">‚úï</button>
                </div>
            </div>
            
            <!-- Working Zone -->
            <div class="working-zone empty" id="working-zone">
                <div class="working-empty">
                    <div class="working-title">Click on a task to start working on it</div>
                    <div>Focus on one thing at a time</div>
                </div>
            </div>
            
            <!-- Input -->
            <div class="input-container">
                <input type="text" id="task-input" placeholder="What's on your mind? ‚Ä¶ (press N to add)">
            </div>

            <!-- Controls -->
            <div class="controls">
                <div class="filter-buttons">
                    <button class="filter-btn active" data-filter="all">All Tasks</button>
                    <button class="filter-btn" data-filter="today">Today</button>
                    <button class="filter-btn" data-filter="week">This Week</button>
                    <button class="filter-btn" data-filter="overdue">Overdue</button>
                </div>
                <select class="sort-select" id="sort-select">
                    <option value="due">Sort by Due Date</option>
                    <option value="xp">Sort by XP</option>
                    <option value="effort">Sort by Effort</option>
                    <option value="category">Sort by Category</option>
                </select>
            </div>

            <!-- Tasks -->
            <div class="task-section">
                <div class="section-header">
                    <div class="task-header-left">
                        <span>Tasks (<span id="task-count">0</span>)</span>
                        <span class="task-count-info" id="task-display-info"></span>
                    </div>
                    <div class="search-morphing" id="search-morphing">
                        <div class="search-icon-morph" id="search-icon-morph">üîç</div>
                        <input type="text" class="search-input-morph" id="search-input" placeholder="Start typing...">
                        <div class="search-clear-morph" id="search-clear">‚úï</div>
                    </div>
                </div>
                <ul class="task-list" id="task-list"></ul>
                <button class="show-more-btn hidden" id="show-more-btn">Show More Tasks</button>
                <div class="empty-state hidden" id="empty-state">
                    No tasks yet. Press N to add your first task!
                </div>
            </div>

            <!-- Ideas -->
            <div class="ideas-section" id="ideas-section">
                <div class="ideas-header" onclick="toggleIdeasSection()">
                    <div class="section-header">üí° Ideas (<span id="ideas-count">0</span>)</div>
                    <span class="ideas-toggle">‚ñº</span>
                </div>
                <div id="ideas-list" class="ideas-list"></div>
            </div>
        </div>
        
        <!-- Right Widget -->
        <div class="right-widget">
            <div class="widget-section">
                <div class="widget-title">Level & Progress</div>
                <div class="level-info">
                    Level <span id="current-level">1</span>
                </div>
                <div class="xp-progress-container">
                    <div class="xp-bar">
                        <div class="xp-progress">
                            <div class="xp-fill" id="xp-fill"></div>
                        </div>
                        <span id="xp-text">0/500 XP</span>
                    </div>
                </div>
            </div>
            
            <div class="widget-section">
                <div class="widget-title">Today's Stats</div>
                <div class="today-stats">
                    <div class="stat-item">
                        <span class="stat-value" id="tasks-today">0</span>
                        <span class="stat-label">tasks completed</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="xp-today">0</span>
                        <span class="stat-label">XP earned</span>
                    </div>
                </div>
            </div>
            
            <div class="widget-section">
                <div class="widget-title">Streak</div>
                <div style="text-align: center; font-size: 1.5rem;">
                    <span>üî•</span>
                    <span id="streak-days" style="font-weight: bold;">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Palette Modal -->
    <div id="palette-modal" class="hidden" role="dialog" aria-labelledby="palette-dialog-title" aria-modal="true">
        <div class="modal-overlay" id="modal-overlay"></div>
        <div class="palette-modal">
            <div class="palette-title" id="palette-dialog-title">Quick Settings ‚Äî press a number, then Enter</div>
            <div class="sr-only" aria-live="polite">Use arrow keys to navigate between fields, number keys to select options</div>
            <div class="keyboard-hints" style="text-align: center; font-size: 0.9rem; color: var(--color-muted); margin-bottom: 1rem;">
                <kbd>‚Üë‚Üì</kbd> Navigate fields ¬∑ <kbd>‚Üê‚Üí</kbd> Navigate options ¬∑ <kbd>1-6</kbd> Select ¬∑ <kbd>Space</kbd> Choose
            </div>
            
            <div class="palette-field">
                <div class="palette-label">Title: <span id="palette-title"></span></div>
            </div>
            
            <div class="palette-field" id="category-field" role="group" aria-labelledby="category-label">
                <div class="palette-label" id="category-label">Category (default ‚òë Other)</div>
                <div class="palette-options" id="category-options" role="radiogroup" aria-labelledby="category-label">
                    <div class="palette-option" data-value="admin" role="radio" aria-checked="false"><kbd>1</kbd> Admin</div>
                    <div class="palette-option" data-value="selling" role="radio" aria-checked="false"><kbd>2</kbd> Selling</div>
                    <div class="palette-option" data-value="research" role="radio" aria-checked="false"><kbd>3</kbd> Research</div>
                    <div class="palette-option" data-value="product" role="radio" aria-checked="false"><kbd>4</kbd> Product</div>
                    <div class="palette-option" data-value="hiring" role="radio" aria-checked="false"><kbd>5</kbd> Hiring</div>
                    <div class="palette-option selected" data-value="other" role="radio" aria-checked="true"><kbd>6</kbd> Other</div>
                </div>
            </div>
            
            <div class="palette-field" id="priority-field" role="group" aria-labelledby="priority-label">
                <div class="palette-label" id="priority-label">Priority (default ‚òë Medium)</div>
                <div class="palette-options" id="priority-options" role="radiogroup" aria-labelledby="priority-label">
                    <div class="palette-option" data-value="1" role="radio" aria-checked="false"><kbd>1</kbd> Low</div>
                    <div class="palette-option selected" data-value="2" role="radio" aria-checked="true"><kbd>2</kbd> Medium</div>
                    <div class="palette-option" data-value="3" role="radio" aria-checked="false"><kbd>3</kbd> High</div>
                </div>
            </div>
            
            <div class="palette-field" id="effort-field" role="group" aria-labelledby="effort-label">
                <div class="palette-label" id="effort-label">Effort (default ‚òë 30m)</div>
                <div class="palette-options" id="effort-options" role="radiogroup" aria-labelledby="effort-label">
                    <div class="palette-option" data-value="15m" role="radio" aria-checked="false">
                        <kbd>1</kbd> 15m
                        <div class="xp-preview" id="xp-15m"></div>
                    </div>
                    <div class="palette-option selected" data-value="30m" role="radio" aria-checked="true">
                        <kbd>2</kbd> 30m
                        <div class="xp-preview" id="xp-30m"></div>
                    </div>
                    <div class="palette-option" data-value="1h" role="radio" aria-checked="false">
                        <kbd>3</kbd> 1h
                        <div class="xp-preview" id="xp-1h"></div>
                    </div>
                    <div class="palette-option" data-value="4h" role="radio" aria-checked="false">
                        <kbd>4</kbd> ¬Ω-day
                        <div class="xp-preview" id="xp-4h"></div>
                    </div>
                </div>
            </div>
            
            <div class="palette-field" id="friction-field" role="group" aria-labelledby="friction-label">
                <div class="palette-label" id="friction-label">Friction (default ‚òë üçÉ)</div>
                <div class="palette-options" id="friction-options" role="radiogroup" aria-labelledby="friction-label">
                    <div class="palette-option selected" data-value="1" role="radio" aria-checked="true"><kbd>1</kbd> üçÉ</div>
                    <div class="palette-option" data-value="2" role="radio" aria-checked="false"><kbd>2</kbd> üí®</div>
                    <div class="palette-option" data-value="3" role="radio" aria-checked="false"><kbd>3</kbd> üå™Ô∏è</div>
                </div>
            </div>
            
            <div class="palette-actions">
                <button class="palette-btn" id="palette-save">Enter = Save</button>
                <button class="palette-btn" id="palette-cancel">Esc = Cancel</button>
            </div>
        </div>
    </div>

    <!-- Confetti Container -->
    <div class="confetti-container" id="confetti-container"></div>

    <!-- Main application script -->
    <script>
        // Keep minimal global variables for inline event handlers
        const API_URL = 'http://localhost:8000';
        let ws = null;
        let currentData = { today: [], ideas: [], backlog: [] };
        let allTasks = [];
        let currentFilter = 'all';
        let currentSort = 'due';
        let audioContext = null;
        let workingTask = null;
        let workingStartTime = null;
        let workingTimer = null;
        let draggedElement = null;
        let showAllTasks = false;
        let expandedTasks = new Set(); // Track which tasks are expanded
        let northStarTask = null; // Today's North Star task
        let searchTerm = ''; // Current search term

        // Focus management for palette
        class PaletteFocusManager {
            constructor() {
                this.fields = ['category-options', 'priority-options', 'effort-options', 'friction-options'];
                this.currentFieldIndex = 0;
                this.currentOptionIndex = 0;
                this.isNavigating = false;
            }

            init() {
                const modal = document.getElementById('palette-modal');
                const mode = modal.dataset.mode || 'task';
                
                // In idea mode, only focus on visible fields
                if (mode === 'idea') {
                    this.fields = ['category-options'];
                    // Add other fields if they become visible
                    if (!document.getElementById('priority-field').classList.contains('hidden')) {
                        this.fields = ['category-options', 'priority-options', 'effort-options', 'friction-options'];
                    }
                } else {
                    this.fields = ['category-options', 'priority-options', 'effort-options', 'friction-options'];
                }
                
                this.currentFieldIndex = 0;
                this.currentOptionIndex = this.getSelectedIndex(this.fields[0]) || 0;
                this.updateFieldFocus();
                this.updateOptionFocus();
            }

            navigateFields(direction) {
                this.currentFieldIndex = Math.max(0, Math.min(this.fields.length - 1, this.currentFieldIndex + direction));
                this.currentOptionIndex = this.getSelectedIndex(this.fields[this.currentFieldIndex]) || 0;
                this.updateFieldFocus();
                this.updateOptionFocus();
                this.announceField();
            }

            navigateOptions(direction) {
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                this.currentOptionIndex = Math.max(0, Math.min(options.length - 1, this.currentOptionIndex + direction));
                this.updateOptionFocus();
            }

            selectByNumber(num) {
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                const targetIndex = num - 1; // All fields use 0-based index
                
                if (options[targetIndex]) {
                    this.currentOptionIndex = targetIndex;
                    this.selectCurrentOption();
                    this.updateOptionFocus();
                }
            }

            selectCurrentOption() {
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                
                // Remove selected from all options in this field
                options.forEach(opt => {
                    opt.classList.remove('selected');
                    opt.setAttribute('aria-checked', 'false');
                });
                
                // Add selected to current option
                if (options[this.currentOptionIndex]) {
                    options[this.currentOptionIndex].classList.add('selected');
                    options[this.currentOptionIndex].setAttribute('aria-checked', 'true');
                    
                    // Update XP previews if friction field
                    if (this.fields[this.currentFieldIndex] === 'friction-options') {
                        updateXPPreviews();
                    }
                }
            }

            getSelectedIndex(fieldId) {
                const field = document.getElementById(fieldId);
                const options = field.querySelectorAll('.palette-option');
                let selectedIndex = 0;
                options.forEach((opt, index) => {
                    if (opt.classList.contains('selected')) {
                        selectedIndex = index;
                    }
                });
                return selectedIndex;
            }

            updateFieldFocus() {
                // Remove all field focus
                document.querySelectorAll('.palette-field').forEach(field => {
                    field.classList.remove('focused');
                    field.removeAttribute('aria-current');
                });

                // Add focus to current field
                const currentFieldElement = document.getElementById(this.fields[this.currentFieldIndex]);
                if (currentFieldElement) {
                    const fieldContainer = currentFieldElement.closest('.palette-field');
                    fieldContainer.classList.add('focused');
                    fieldContainer.setAttribute('aria-current', 'true');
                }
            }

            updateOptionFocus() {
                // Remove all option focus
                document.querySelectorAll('.palette-option').forEach(opt => {
                    opt.classList.remove('keyboard-focus');
                    opt.removeAttribute('aria-selected');
                    opt.tabIndex = -1;
                });

                // Add focus to current option
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                if (options[this.currentOptionIndex]) {
                    options[this.currentOptionIndex].classList.add('keyboard-focus');
                    options[this.currentOptionIndex].setAttribute('aria-selected', 'true');
                    options[this.currentOptionIndex].tabIndex = 0;
                    // Don't auto-focus to prevent scroll jumping
                    if (this.isNavigating) {
                        options[this.currentOptionIndex].focus({ preventScroll: true });
                    }
                }
            }

            announceField() {
                // For screen readers
                const fieldLabels = {
                    'category-options': 'Category field',
                    'priority-options': 'Priority field',
                    'effort-options': 'Effort field',
                    'friction-options': 'Friction field'
                };
                
                const announcement = document.createElement('div');
                announcement.className = 'sr-only';
                announcement.setAttribute('aria-live', 'polite');
                announcement.textContent = `Now in ${fieldLabels[this.fields[this.currentFieldIndex]]}`;
                document.body.appendChild(announcement);
                setTimeout(() => announcement.remove(), 1000);
            }
        }

        const paletteFocusManager = new PaletteFocusManager();

        // Initialize WebSocket
        function initWebSocket() {
            ws = new WebSocket('ws://localhost:8000/ws');
            
            ws.onopen = () => {
                console.log('WebSocket connected');
            };
            
            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                if (message.type === 'file_changed' || message.type === 'update') {
                    currentData = message.data;
                    processAndRender();
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(initWebSocket, 1000);
            };
        }

        // Fetch initial data
        async function loadTodos() {
            try {
                const response = await fetch(`${API_URL}/api/todos`);
                currentData = await response.json();
                processAndRender();
                
                // Load stats
                await loadStats();
            } catch (error) {
                console.error('Error loading todos:', error);
            }
        }

        // Load stats
        async function loadStats() {
            try {
                const response = await fetch(`${API_URL}/api/stats`);
                const stats = await response.json();
                updateStats(stats);
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        // Process data into flat list
        function processAndRender() {
            allTasks = [];
            
            // Collect all tasks from all sections
            Object.entries(currentData).forEach(([section, tasks]) => {
                tasks.forEach(task => {
                    if (!task.is_idea) {
                        collectTasks(task, section);
                    }
                });
            });
            
            // Render based on current filter and sort
            renderTasks();
            renderIdeas();
            updateCounts();
            
            // Update working task if it exists
            if (workingTask) {
                const updatedTask = allTasks.find(t => t.id === workingTask.id);
                if (updatedTask) {
                    workingTask = updatedTask;
                    updateWorkingZone();
                }
            }
            
            // Restore UI state on initial load
            if (!window.uiStateRestored) {
                window.uiStateRestored = true;
                restoreUIState();
            }
        }

        function collectTasks(task, section, parentTask = null) {
            const taskWithSection = { ...task, section, parentTask };
            allTasks.push(taskWithSection);
            
            if (task.subtasks && task.subtasks.length > 0) {
                task.subtasks.forEach(subtask => {
                    collectTasks(subtask, section, task);
                });
            }
        }

        // Filter tasks
        function filterTasks(tasks) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 7);
            
            return tasks.filter(task => {
                if (currentFilter === 'all') return true;
                
                if (!task.due_date) return false;
                
                const dueDate = new Date(task.due_date);
                dueDate.setHours(0, 0, 0, 0);
                
                switch (currentFilter) {
                    case 'today':
                        return dueDate.getTime() === today.getTime();
                    case 'week':
                        return dueDate >= weekStart && dueDate < weekEnd;
                    case 'overdue':
                        return dueDate < today && !task.is_completed;
                    default:
                        return true;
                }
            });
        }

        // Sort tasks
        function sortTasks(tasks) {
            return tasks.sort((a, b) => {
                switch (currentSort) {
                    case 'due':
                        if (!a.due_date && !b.due_date) return 0;
                        if (!a.due_date) return 1;
                        if (!b.due_date) return -1;
                        return new Date(a.due_date) - new Date(b.due_date);
                    case 'xp':
                        return calculateXP(b) - calculateXP(a);
                    case 'effort':
                        const effortOrder = { '15m': 1, '30m': 2, '1h': 3, '4h': 4, '1d': 5 };
                        return (effortOrder[a.effort] || 99) - (effortOrder[b.effort] || 99);
                    case 'category':
                        return (a.category || 'zzz').localeCompare(b.category || 'zzz');
                    default:
                        return 0;
                }
            });
        }

        // Search functionality
        function searchTasks(tasks, searchQuery) {
            const query = searchQuery.toLowerCase().trim();
            if (!query) return tasks;
            
            const matchingTasks = new Set();
            const tasksToReturn = new Set();
            
            // Search through all tasks and subtasks
            function searchInTask(task, parentTask = null) {
                const taskMatches = task.title.toLowerCase().includes(query) || 
                                  (task.category && task.category.toLowerCase().includes(query));
                
                if (taskMatches) {
                    matchingTasks.add(task);
                    // If this is a subtask that matches, include its parent
                    if (parentTask && !parentTask.is_completed) {
                        tasksToReturn.add(parentTask);
                    } else if (!parentTask && !task.is_completed) {
                        // If this is a top-level task that matches, include it
                        tasksToReturn.add(task);
                    }
                }
                
                // Search in subtasks
                if (task.subtasks && task.subtasks.length > 0) {
                    task.subtasks.forEach(subtask => {
                        searchInTask(subtask, task);
                    });
                    
                    // If any subtask matches, include the parent task
                    const hasMatchingSubtask = task.subtasks.some(st => matchingTasks.has(st));
                    if (hasMatchingSubtask && !task.is_completed) {
                        tasksToReturn.add(task);
                    }
                }
            }
            
            // Search through all tasks
            tasks.forEach(task => searchInTask(task));
            
            // Return all matching tasks (both top-level and parents with matching subtasks)
            return Array.from(tasksToReturn);
        }

        // Render tasks
        function renderTasks() {
            const container = document.getElementById('task-list');
            container.innerHTML = '';
            
            let tasksToDisplay = [];
            
            if (searchTerm) {
                // Search mode: find matching tasks and subtasks
                const searchResults = searchTasks(allTasks, searchTerm);
                tasksToDisplay = searchResults.filter(task => !task.is_completed);
                
                // Always show all results in search mode
                showAllTasks = true;
            } else {
                // Normal mode
                const filteredTasks = filterTasks(allTasks);
                const sortedTasks = sortTasks(filteredTasks);
                tasksToDisplay = sortedTasks.filter(task => !task.parentTask && !task.is_completed);
            }
            
            if (tasksToDisplay.length === 0) {
                document.getElementById('empty-state').classList.remove('hidden');
                document.getElementById('show-more-btn').classList.add('hidden');
                document.getElementById('task-display-info').textContent = searchTerm ? 'No matching tasks found' : '';
            } else {
                document.getElementById('empty-state').classList.add('hidden');
                
                // In search mode, show all; otherwise limit to top 5
                const tasksToShow = (searchTerm || showAllTasks) ? tasksToDisplay : tasksToDisplay.slice(0, 5);
                const hasMore = !searchTerm && tasksToDisplay.length > 5;
                
                tasksToShow.forEach((task, index) => {
                    const element = createTaskElement(task);
                    if (index < 5 && !showAllTasks && !searchTerm) {
                        element.classList.add('top-5');
                    }
                    container.appendChild(element);
                    
                    // Add subtasks if parent is expanded or in search mode
                    if ((expandedTasks.has(task.id) || searchTerm) && task.subtasks && task.subtasks.length > 0) {
                        task.subtasks.forEach(subtask => {
                            const subtaskElement = createTaskElement(subtask, true);
                            subtaskElement.classList.add('visible');
                            container.appendChild(subtaskElement);
                        });
                    }
                });
                
                // Update display info and show more button
                if (searchTerm) {
                    document.getElementById('task-display-info').textContent = `(${tasksToDisplay.length} matching tasks)`;
                    document.getElementById('show-more-btn').classList.add('hidden');
                } else if (hasMore) {
                    const remaining = tasksToDisplay.length - 5;
                    document.getElementById('task-display-info').textContent = 
                        showAllTasks ? `(showing all ${tasksToDisplay.length} tasks)` : `(showing top 5)`;
                    
                    const showMoreBtn = document.getElementById('show-more-btn');
                    showMoreBtn.textContent = showAllTasks ? 'Show Only Top 5' : `Show ${remaining} More Tasks`;
                    showMoreBtn.classList.remove('hidden');
                } else {
                    document.getElementById('task-display-info').textContent = '';
                    document.getElementById('show-more-btn').classList.add('hidden');
                }
            }
        }

        function createTaskElement(task, isSubtask = false) {
            const li = document.createElement('li');
            li.className = `task-item ${isSubtask ? 'subtask' : ''} ${task.is_completed ? 'completed' : ''}`;
            li.dataset.taskId = task.id;
            
            // Enable drag & drop for non-subtasks
            if (!isSubtask && !task.is_completed) {
                li.draggable = true;
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragend', handleDragEnd);
            }
            
            // Check if overdue or due today
            if (task.due_date && !task.is_completed) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const dueDate = new Date(task.due_date);
                dueDate.setHours(0, 0, 0, 0);
                
                if (dueDate < today) {
                    li.classList.add('overdue');
                } else if (dueDate.getTime() === today.getTime()) {
                    li.classList.add('due-today');
                }
            }
            
            const checkbox = document.createElement('div');
            checkbox.className = `task-checkbox ${task.is_completed ? 'checked' : ''}`;
            checkbox.onclick = () => toggleTask(task);
            
            const content = document.createElement('div');
            content.className = 'task-content';
            
            const main = document.createElement('div');
            main.className = 'task-main';
            
            const title = document.createElement('div');
            title.className = 'task-title';
            
            // Add subtask toggle if has subtasks (before title text)
            if (task.subtasks && task.subtasks.length > 0 && !isSubtask) {
                const isExpanded = expandedTasks.has(task.id);
                if (isExpanded) {
                    li.classList.add('subtasks-expanded');
                }
                
                const toggle = document.createElement('span');
                toggle.className = 'subtask-toggle';
                toggle.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleSubtasks(li, task);
                };
                title.appendChild(toggle);
            }
            
            const titleText = document.createElement('span');
            titleText.textContent = task.title;
            title.appendChild(titleText);
            
            const meta = document.createElement('div');
            meta.className = 'task-meta';
            
            if (task.category) {
                const category = document.createElement('span');
                category.className = 'task-category';
                category.textContent = `@${task.category}`;
                meta.appendChild(category);
            }
            
            if (task.effort) {
                const effort = document.createElement('span');
                effort.className = 'task-effort';
                effort.textContent = task.effort;
                meta.appendChild(effort);
            }
            
            if (task.friction) {
                const friction = document.createElement('span');
                friction.className = 'task-friction';
                const frictionIcons = ['', 'üçÉ', 'üí®', 'üå™Ô∏è'];
                friction.textContent = frictionIcons[task.friction] || 'üçÉ';
                meta.appendChild(friction);
            }
            
            if (task.due_date) {
                const due = document.createElement('span');
                due.className = 'task-due';
                const dueDate = new Date(task.due_date);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                if (dueDate < today && !task.is_completed) {
                    due.style.color = 'var(--color-error)';
                } else if (dueDate.toDateString() === today.toDateString()) {
                    due.style.color = 'var(--color-warning)';
                }
                
                due.textContent = `üìÖ ${dueDate.toLocaleDateString()}`;
                meta.appendChild(due);
            }
            
            if (task.subtasks && task.subtasks.length > 0) {
                const progress = document.createElement('div');
                progress.className = 'task-progress';
                const fill = document.createElement('div');
                fill.className = 'task-progress-fill';
                const completed = task.subtasks.filter(st => st.is_completed).length;
                const total = task.subtasks.length;
                fill.style.width = `${(completed / total) * 100}%`;
                progress.appendChild(fill);
                meta.appendChild(progress);
                
                const progressText = document.createElement('span');
                progressText.textContent = `${completed}/${total}`;
                meta.appendChild(progressText);
            }
            
            main.appendChild(title);
            main.appendChild(meta);
            content.appendChild(main);
            
            // XP display
            const xp = document.createElement('div');
            xp.className = 'task-xp';
            const xpValue = calculateXP(task);
            xp.textContent = `+${xpValue} XP`;
            
            // Show bonus for subtasks
            if (task.subtasks && task.subtasks.length > 0) {
                const completed = task.subtasks.filter(st => st.is_completed).length;
                if (completed === task.subtasks.length && completed > 0) {
                    xp.textContent = `+${Math.round(xpValue * 1.5)} XP ‚ú®`;
                    xp.style.background = 'var(--color-success)';
                }
            }
            
            content.appendChild(xp);
            
            // Add action buttons for non-completed tasks
            if (!task.is_completed && !isSubtask) {
                const actions = document.createElement('div');
                actions.className = 'task-actions';
                
                const workBtn = document.createElement('button');
                workBtn.className = 'work-btn';
                // Use HTML entities for better compatibility across browsers
                workBtn.innerHTML = workingTask?.id === task.id ? '&#9208;' : '&#9654;';
                workBtn.title = workingTask?.id === task.id ? 'Working' : 'Work on this';
                workBtn.disabled = workingTask?.id === task.id;
                workBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (workingTask) {
                        showSwitchModal(task);
                    } else {
                        startWorkingOn(task);
                    }
                };
                actions.appendChild(workBtn);
                
                // Add crown button if not already crowned
                if (!northStarTask || northStarTask.id !== task.id) {
                    const crownBtn = document.createElement('button');
                    crownBtn.className = 'crown-btn';
                    crownBtn.innerHTML = '‚≠ê';
                    crownBtn.title = 'Set as North Star';
                    crownBtn.onclick = (e) => {
                        e.stopPropagation();
                        setNorthStar(task, !northStarTask); // Only give XP if no North Star is set
                    };
                    actions.appendChild(crownBtn);
                }
                
                // Add subtask button
                const subtaskBtn = document.createElement('button');
                subtaskBtn.className = 'subtask-btn';
                subtaskBtn.textContent = '+ Add Subtask';
                subtaskBtn.onclick = (e) => {
                    e.stopPropagation();
                    showSubtaskInput(task);
                };
                actions.appendChild(subtaskBtn);
                
                content.appendChild(actions);
            }
            
            li.appendChild(checkbox);
            li.appendChild(content);
            
            return li;
        }

        function renderIdeas() {
            const container = document.getElementById('ideas-list');
            container.innerHTML = '';
            
            const ideas = [];
            Object.entries(currentData).forEach(([section, tasks]) => {
                tasks.forEach(task => {
                    if (task.is_idea) {
                        ideas.push({ ...task, section });
                    }
                });
            });
            
            ideas.forEach(idea => {
                const div = document.createElement('div');
                div.className = 'idea-item';
                div.dataset.ideaId = idea.id;
                div.dataset.section = idea.section;
                
                const text = document.createElement('span');
                text.textContent = `üí° ${idea.title}`;
                if (idea.category) {
                    text.textContent += ` @${idea.category}`;
                }
                div.appendChild(text);
                
                // Create actions container
                const actions = document.createElement('div');
                actions.className = 'idea-actions';
                
                const convertBtn = document.createElement('button');
                convertBtn.className = 'convert-btn';
                convertBtn.textContent = '‚Üí Convert to Task';
                convertBtn.onclick = (e) => {
                    e.stopPropagation();
                    convertIdeaToTask(idea);
                };
                actions.appendChild(convertBtn);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '‚úï Delete';
                deleteBtn.title = 'Delete idea';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteIdea(idea);
                };
                actions.appendChild(deleteBtn);
                
                div.appendChild(actions);
                container.appendChild(div);
            });
        }

        function updateCounts() {
            const taskCount = allTasks.filter(t => !t.is_completed).length;
            document.getElementById('task-count').textContent = taskCount;
            
            let ideasCount = 0;
            Object.values(currentData).forEach(section => {
                section.forEach(task => {
                    if (task.is_idea) ideasCount++;
                });
            });
            document.getElementById('ideas-count').textContent = ideasCount;
        }

        function updateStats(stats) {
            // Update level
            document.getElementById('current-level').textContent = stats.level;
            
            // Update XP bar
            const xpPercent = (stats.xp_progress / stats.xp_for_next_level) * 100;
            document.getElementById('xp-fill').style.width = `${xpPercent}%`;
            document.getElementById('xp-text').textContent = `${stats.xp_progress}/${stats.xp_for_next_level} XP`;
            
            // Update today stats
            document.getElementById('tasks-today').textContent = stats.completed_today;
            document.getElementById('xp-today').textContent = stats.xp_today;
            
            // Update streak
            document.getElementById('streak-days').textContent = `${stats.streak}-day streak`;
        }

        // Working Zone Functions
        function startWorkingOn(task) {
            workingTask = task;
            workingStartTime = new Date();
            updateWorkingZone();
            startWorkingTimer();
            saveUIState();
        }
        
        function stopWorking() {
            if (workingTimer) {
                clearInterval(workingTimer);
                workingTimer = null;
            }
            workingTask = null;
            workingStartTime = null;
            updateWorkingZone();
            saveUIState();
        }
        
        function updateWorkingZone() {
            const zone = document.getElementById('working-zone');
            
            if (!workingTask) {
                zone.classList.add('empty');
                zone.innerHTML = `
                    <div class="working-empty">
                        Click on a task to start working on it
                    </div>
                `;
            } else {
                zone.classList.remove('empty');
                const elapsed = workingStartTime ? Math.floor((new Date() - workingStartTime) / 1000) : 0;
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const progressPercent = Math.min((elapsed / (30 * 60)) * 100, 100); // 30 min = 100%
                
                zone.innerHTML = `
                    <div class="working-task">
                        <div class="task-checkbox ${workingTask.is_completed ? 'checked' : ''}" onclick="completeWorkingTask()"></div>
                        <div class="working-content">
                            <div class="working-title">${workingTask.title}</div>
                            <div class="working-meta">
                                ${workingTask.category ? `<span>@${workingTask.category}</span>` : ''}
                                <span>${workingTask.effort || '30m'}</span>
                                <span>${['', 'üçÉ', 'üí®', 'üå™Ô∏è'][workingTask.friction || 2]}</span>
                            </div>
                        </div>
                        <div class="working-timer">
                            ${minutes}:${seconds.toString().padStart(2, '0')}
                        </div>
                        <button class="stop-working-btn" onclick="stopWorking()">Stop</button>
                    </div>
                    <div class="working-progress">
                        <div class="working-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                `;
            }
        }
        
        function startWorkingTimer() {
            if (workingTimer) clearInterval(workingTimer);
            workingTimer = setInterval(updateWorkingZone, 1000);
        }
        
        function completeWorkingTask() {
            if (!workingTask) return;
            
            // Mark the task as completed
            toggleTask(workingTask);
            
            // Stop working on it
            stopWorking();
        }
        
        // North Star Task Functions
        function setNorthStar(task, giveXP = true) {
            const isFirstTime = !northStarTask;
            northStarTask = task;
            updateNorthStarSection();
            renderTasks();
            
            if (isFirstTime && giveXP) {
                // Give 25 XP for planning
                showToast(`‚≠ê Great choice! +25 XP for planning your day`);
                // Update stats with bonus XP
                fetch(`${API_URL}/api/stats/bonus`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ xp: 25, reason: 'north_star_set' })
                }).then(() => loadStats());
            } else {
                showToast(`‚≠ê ${task.title} is now your North Star!`);
            }
            
            saveUIState();
        }
        
        function showNorthStarPicker() {
            // Get uncompleted tasks
            const availableTasks = allTasks.filter(t => !t.is_completed && !t.parentTask);
            
            if (availableTasks.length === 0) {
                showToast('No tasks available. Add some tasks first!');
                return;
            }
            
            // Create modal
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const modal = document.createElement('div');
            modal.className = 'north-star-picker-modal';
            modal.innerHTML = `
                <h3>Choose Your North Star Task</h3>
                <p>Select your main focus for today and earn +25 XP!</p>
                <div class="north-star-task-list">
                    ${availableTasks.map(task => `
                        <div class="north-star-option" data-task-id="${task.id}">
                            <div class="task-title">${task.title}</div>
                            <div class="task-meta">
                                ${task.category ? `<span>@${task.category}</span>` : ''}
                                <span>${task.effort || '30m'}</span>
                                <span>${calculateXP(task) * 3} XP (3x bonus)</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <button class="cancel-btn" onclick="closeNorthStarPicker()">Cancel</button>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            // Add click handlers
            modal.querySelectorAll('.north-star-option').forEach(option => {
                option.onclick = () => {
                    const taskId = option.dataset.taskId;
                    const task = allTasks.find(t => t.id === taskId);
                    if (task) {
                        setNorthStar(task);
                        closeNorthStarPicker();
                    }
                };
            });
            
            overlay.onclick = closeNorthStarPicker;
        }
        
        function closeNorthStarPicker() {
            document.querySelector('.modal-overlay')?.remove();
            document.querySelector('.north-star-picker-modal')?.remove();
        }
        
        function removeNorthStar() {
            northStarTask = null;
            updateNorthStarSection();
            renderTasks();
            saveUIState();
        }
        
        function updateNorthStarSection() {
            const section = document.getElementById('north-star-section');
            
            if (!northStarTask) {
                // Show empty state
                section.innerHTML = `
                    <div class="north-star-empty-state">
                        <div class="north-star-icon">‚≠ê</div>
                        <div class="north-star-empty-content">
                            <div class="north-star-empty-title">What's your main focus today?</div>
                            <button class="choose-north-star-btn" onclick="showNorthStarPicker()">
                                Choose from your tasks ‚ñº
                                <span class="xp-reward">+25 XP</span>
                            </button>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Show selected task
            section.innerHTML = `
                <div class="north-star-icon">‚≠ê</div>
                <div class="north-star-content">
                    <div class="north-star-label">Today's North Star</div>
                    <div class="north-star-title" id="north-star-title">${northStarTask.title}</div>
                    <div class="north-star-meta">
                        <span id="north-star-category">${northStarTask.category ? `@${northStarTask.category}` : ''}</span>
                        <span id="north-star-effort">${northStarTask.effort || '30m'}</span>
                        <span class="north-star-xp" id="north-star-xp"><strong>${calculateXP(northStarTask) * 3} XP ‚Ä¢ 3x bonus</strong></span>
                    </div>
                </div>
                <div class="north-star-actions">
                    <button class="work-btn" id="north-star-work" title="Work on this">${workingTask?.id === northStarTask.id ? '‚è∏' : '‚ñ∂'}</button>
                    <button class="uncrown-btn" id="north-star-uncrown" title="Remove star">‚úï</button>
                </div>
            `;
            
            // Re-attach event listeners
            const workBtn = document.getElementById('north-star-work');
            if (workBtn) {
                workBtn.disabled = workingTask?.id === northStarTask.id;
                workBtn.onclick = () => {
                    if (workingTask && workingTask.id !== northStarTask.id) {
                        showSwitchModal(northStarTask);
                    } else if (!workingTask) {
                        startWorkingOn(northStarTask);
                    }
                };
            }
            
            const uncrownBtn = document.getElementById('north-star-uncrown');
            if (uncrownBtn) {
                uncrownBtn.onclick = removeNorthStar;
            }
        }
        
        // UI State Persistence
        function saveUIState() {
            const uiState = {
                northStarTaskId: northStarTask ? northStarTask.id : null,
                workingTaskId: workingTask ? workingTask.id : null,
                workingStartTime: workingStartTime ? workingStartTime.toISOString() : null
            };
            localStorage.setItem('confettiTodoUIState', JSON.stringify(uiState));
        }
        
        function restoreUIState() {
            try {
                const savedState = localStorage.getItem('confettiTodoUIState');
                if (!savedState) return;
                
                const uiState = JSON.parse(savedState);
                
                // Restore North Star
                if (uiState.northStarTaskId) {
                    const task = findTaskById(uiState.northStarTaskId);
                    if (task && !task.is_completed) {
                        northStarTask = task;
                        updateNorthStarSection();
                    }
                }
                
                // Restore Working Task
                if (uiState.workingTaskId && uiState.workingStartTime) {
                    const task = findTaskById(uiState.workingTaskId);
                    if (task && !task.is_completed) {
                        workingTask = task;
                        workingStartTime = new Date(uiState.workingStartTime);
                        updateWorkingZone();
                        startWorkingTimer();
                    }
                }
            } catch (error) {
                console.error('Error restoring UI state:', error);
            }
        }
        
        function findTaskById(id) {
            // First try to find in allTasks array (if available)
            if (allTasks && allTasks.length > 0) {
                const found = allTasks.find(t => t.id === id);
                if (found) return found;
            }
            
            // Fallback to searching in currentData
            for (const section of Object.values(currentData)) {
                for (const task of section) {
                    if (task.id === id) return task;
                    // Check subtasks
                    if (task.subtasks) {
                        for (const subtask of task.subtasks) {
                            if (subtask.id === id) return subtask;
                        }
                    }
                }
            }
            return null;
        }
        
        function showSwitchModal(newTask) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const modal = document.createElement('div');
            modal.className = 'switch-modal';
            
            let countdown = 3;
            modal.innerHTML = `
                <h3>Are you sure you want to switch tasks?</h3>
                <p>You're currently working on "${workingTask.title}"</p>
                <div class="countdown">${countdown}</div>
                <div class="switch-modal-buttons">
                    <button onclick="confirmSwitch('${newTask.id}')">Yes, switch</button>
                    <button class="confirm" onclick="cancelSwitch()">Keep working</button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            const countdownInterval = setInterval(() => {
                countdown--;
                modal.querySelector('.countdown').textContent = countdown;
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    cancelSwitch();
                }
            }, 1000);
            
            window.currentCountdown = countdownInterval;
        }
        
        window.confirmSwitch = (taskId) => {
            if (window.currentCountdown) clearInterval(window.currentCountdown);
            document.querySelector('.modal-overlay').remove();
            document.querySelector('.switch-modal').remove();
            
            const task = allTasks.find(t => t.id === taskId);
            if (task) {
                stopWorking();
                startWorkingOn(task);
            }
        };
        
        window.cancelSwitch = () => {
            if (window.currentCountdown) clearInterval(window.currentCountdown);
            document.querySelector('.modal-overlay')?.remove();
            document.querySelector('.switch-modal')?.remove();
        };
        
        // Make functions global
        window.stopWorking = stopWorking;
        window.completeWorkingTask = completeWorkingTask;
        window.showNorthStarPicker = showNorthStarPicker;
        window.closeNorthStarPicker = closeNorthStarPicker;

        async function toggleTask(task) {
            const wasCompleted = task.is_completed;
            task.is_completed = !task.is_completed;
            
            if (task.is_completed) {
                task.completed_at = new Date().toISOString();
                
                // Mark all subtasks as completed too
                if (task.subtasks && task.subtasks.length > 0) {
                    markSubtasksCompleted(task.subtasks, task.completed_at);
                }
                
                showConfetti();
                playSound();
                let xp = calculateXP(task);
                
                // Apply 3x bonus if this is the North Star task
                if (northStarTask && northStarTask.id === task.id) {
                    xp *= 3;
                    showToast(`+${xp} XP ‚Äî North Star completed! üåü`);
                    removeNorthStar(); // Remove North Star after completion
                } else {
                    showToast(`+${xp} XP ‚Äî sweet!`);
                }
            } else {
                task.completed_at = null;
                
                // Optionally, unmark subtasks too when uncompleting parent
                if (task.subtasks && task.subtasks.length > 0) {
                    markSubtasksCompleted(task.subtasks, null, false);
                }
            }
            
            // Update the task in the original data structure
            updateTaskInData(task);
            
            await saveTodos();
            processAndRender();
            await loadStats();
        }
        
        function markSubtasksCompleted(subtasks, completedAt, completed = true) {
            subtasks.forEach(subtask => {
                subtask.is_completed = completed;
                subtask.completed_at = completedAt;
                
                // Recursively mark nested subtasks
                if (subtask.subtasks && subtask.subtasks.length > 0) {
                    markSubtasksCompleted(subtask.subtasks, completedAt, completed);
                }
            });
        }

        function showSubtaskInput(parentTask) {
            // Remove any existing subtask inputs
            document.querySelectorAll('.subtask-input').forEach(input => input.remove());
            
            // Find the parent task element
            const parentElement = document.querySelector(`[data-task-id="${parentTask.id}"]`);
            if (!parentElement) return;
            
            // Create input container
            const inputContainer = document.createElement('div');
            inputContainer.className = 'subtask-input';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Enter subtask title...';
            
            const actions = document.createElement('div');
            actions.className = 'subtask-actions';
            
            const saveBtn = document.createElement('button');
            saveBtn.className = 'save-subtask';
            saveBtn.textContent = 'Add';
            saveBtn.onclick = () => saveSubtask(parentTask, input.value.trim(), inputContainer);
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'cancel-subtask';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => inputContainer.remove();
            
            // Handle Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation();
                    saveSubtask(parentTask, input.value.trim(), inputContainer);
                } else if (e.key === 'Escape') {
                    inputContainer.remove();
                }
            });
            
            actions.appendChild(saveBtn);
            actions.appendChild(cancelBtn);
            inputContainer.appendChild(input);
            inputContainer.appendChild(actions);
            
            // Insert after parent task
            parentElement.parentNode.insertBefore(inputContainer, parentElement.nextSibling);
            input.focus();
        }

        async function saveSubtask(parentTask, title, inputContainer) {
            if (!title) {
                inputContainer.remove();
                return;
            }
            
            // Create new subtask
            const newSubtask = {
                id: `task_${Date.now()}`,
                title: title,
                is_idea: false,
                is_completed: false,
                category: 'other',
                effort: null,
                friction: null,
                due_date: null,
                completed_at: null,
                parent_id: parentTask.id,
                subtasks: []
            };
            
            // Add to parent task's subtasks
            if (!parentTask.subtasks) {
                parentTask.subtasks = [];
            }
            parentTask.subtasks.push(newSubtask);
            
            // Update in data structure
            updateTaskInData(parentTask);
            
            // Save and refresh
            await saveTodos();
            processAndRender();
            
            // Remove input
            inputContainer.remove();
            
            showToast('Subtask added!');
        }

        function updateTaskInData(updatedTask) {
            Object.entries(currentData).forEach(([section, tasks]) => {
                tasks.forEach((task, index) => {
                    if (task.id === updatedTask.id) {
                        tasks[index] = updatedTask;
                    } else if (task.subtasks) {
                        updateSubtask(task.subtasks, updatedTask);
                    }
                });
            });
        }

        function updateSubtask(subtasks, updatedTask) {
            subtasks.forEach((subtask, index) => {
                if (subtask.id === updatedTask.id) {
                    subtasks[index] = updatedTask;
                } else if (subtask.subtasks) {
                    updateSubtask(subtask.subtasks, updatedTask);
                }
            });
        }

        function calculateXP(task) {
            const effortMap = { '15m': 15, '30m': 30, '1h': 60, '4h': 240, '1d': 480 };
            const minutes = effortMap[task.effort] || 30;
            const friction = task.friction || 2;
            let xp = Math.round(100 * Math.pow(1 + minutes / 60, 0.5) * friction);
            
            // Bonus for completed subtasks
            if (task.subtasks && task.subtasks.length > 0) {
                const completed = task.subtasks.filter(st => st.is_completed).length;
                if (completed === task.subtasks.length && completed > 0) {
                    xp = Math.round(xp * 1.5);
                }
            }
            
            return xp;
        }

        function showConfetti() {
            const container = document.getElementById('confetti-container');
            container.innerHTML = '';
            
            for (let i = 0; i < 120; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.style.left = `${Math.random() * 100}%`;
                piece.style.top = `${Math.random() * 100 - 50}%`;
                piece.style.background = ['#0043ff', '#89efbd', '#ffd6d8', '#ffeb3b', '#e91e63'][Math.floor(Math.random() * 5)];
                piece.style.animationDelay = `${Math.random() * 0.3}s`;
                container.appendChild(piece);
                
                setTimeout(() => piece.remove(), 800);
            }
        }

        function playSound() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        
        function convertIdeaToTask(idea) {
            const ideaElement = document.querySelector(`[data-idea-id="${idea.id}"]`);
            if (ideaElement) {
                ideaElement.classList.add('converting');
            }
            
            // Remove from ideas
            const section = idea.section;
            const index = currentData[section].findIndex(i => i.id === idea.id);
            if (index > -1) {
                currentData[section].splice(index, 1);
            }
            
            // Convert to task
            const task = {
                ...idea,
                is_idea: false,
                effort: '30m',
                friction: 2
            };
            
            // Add to today section
            currentData.today.unshift(task);
            
            setTimeout(() => {
                saveTodos();
                renderTasks();
                renderIdeas();
                updateCounts();
                showCelebrationToast('üå± Idea sprouted into task!');
            }, 600);
        }
        
        function deleteIdea(idea) {
            // Add confirmation
            if (!confirm(`Delete idea "${idea.title}"?`)) {
                return;
            }
            
            // Remove from data
            const section = idea.section;
            const index = currentData[section].findIndex(i => i.id === idea.id);
            if (index > -1) {
                currentData[section].splice(index, 1);
            }
            
            // Update UI
            saveTodos();
            renderIdeas();
            updateCounts();
            
            showToast('üóëÔ∏è Idea deleted');
        }
        
        function toggleIdeasSection() {
            const section = document.getElementById('ideas-section');
            section.classList.toggle('collapsed');
            
            // Save preference
            localStorage.setItem('ideas-collapsed', section.classList.contains('collapsed'));
        }
        
        function showCelebrationToast(message) {
            // Remove any existing celebration toasts
            document.querySelectorAll('.celebration-toast').forEach(t => t.remove());
            
            const toast = document.createElement('div');
            toast.className = 'celebration-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.remove(), 3000);
        }
        
        // Drag & Drop Functions
        function handleDragStart(e) {
            draggedElement = e.target.closest('.task-item');
            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', '');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            if (!draggedElement) return;
            
            const container = document.getElementById('task-list');
            const afterElement = getDragAfterElement(container, e.clientY);
            
            if (afterElement == null) {
                container.appendChild(draggedElement);
            } else {
                container.insertBefore(draggedElement, afterElement);
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
            updateTaskOrder();
        }
        
        function handleDragEnd(e) {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
            }
            draggedElement = null;
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging):not(.subtask)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        function updateTaskOrder() {
            // Get current order from DOM
            const taskList = document.getElementById('task-list');
            const orderedIds = [...taskList.querySelectorAll('.task-item:not(.subtask)')]
                .map(el => el.dataset.taskId);
            
            // Reorder tasks in currentData based on DOM order
            const reorderedToday = [];
            orderedIds.forEach(id => {
                const task = currentData.today.find(t => t.id === id);
                if (task) reorderedToday.push(task);
            });
            
            // Keep any remaining tasks that weren't in the DOM
            currentData.today.forEach(task => {
                if (!reorderedToday.find(t => t.id === task.id)) {
                    reorderedToday.push(task);
                }
            });
            
            currentData.today = reorderedToday;
            saveTodos();
        }
        
        // Toggle subtasks
        function toggleSubtasks(element, task) {
            if (expandedTasks.has(task.id)) {
                expandedTasks.delete(task.id);
            } else {
                expandedTasks.add(task.id);
            }
            renderTasks();
        }

        // Save todos
        async function saveTodos() {
            try {
                const response = await fetch(`${API_URL}/api/todos`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currentData)
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Server error:', errorData);
                    showToast('Failed to save task. Please try again.', 'error');
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error('Error saving todos:', error);
                showToast('Failed to save task. Please check your connection.', 'error');
            }
        }

        // Palette handling
        function showPalette(title, mode = 'task') {
            const modal = document.getElementById('palette-modal');
            modal.dataset.mode = mode;
            
            document.getElementById('palette-title').textContent = title;
            modal.classList.remove('hidden');
            
            // Update modal title and hints based on mode
            const dialogTitle = document.getElementById('palette-dialog-title');
            const keyboardHints = modal.querySelector('.keyboard-hints');
            
            if (mode === 'idea') {
                dialogTitle.innerHTML = 'üí° Capture an idea ‚Äî low commitment';
                keyboardHints.innerHTML = '<kbd>Enter</kbd> Save ¬∑ <kbd>Tab</kbd> More options ¬∑ <kbd>Esc</kbd> Cancel';
                
                // Hide non-essential fields for ideas
                ['priority-field', 'effort-field', 'friction-field'].forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) field.classList.add('hidden');
                });
                
                // Show simpler action buttons
                document.getElementById('palette-save').textContent = 'Enter = Capture Idea';
            } else {
                dialogTitle.innerHTML = '‚ö° Quick Settings ‚Äî press a number, then Enter';
                keyboardHints.innerHTML = '<kbd>‚Üë‚Üì</kbd> Navigate fields ¬∑ <kbd>‚Üê‚Üí</kbd> Navigate options ¬∑ <kbd>1-6</kbd> Select ¬∑ <kbd>Space</kbd> Choose';
                
                // Show all fields for tasks
                ['priority-field', 'effort-field', 'friction-field'].forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) field.classList.remove('hidden');
                });
                
                document.getElementById('palette-save').textContent = 'Enter = Save Task';
                updateXPPreviews();
            }
            
            // Reset selections
            document.querySelectorAll('.palette-option').forEach(opt => {
                if (opt.parentElement.id === 'category-options' && opt.dataset.value === 'other') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else if (opt.parentElement.id === 'priority-options' && opt.dataset.value === '2') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else if (opt.parentElement.id === 'effort-options' && opt.dataset.value === '30m') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else if (opt.parentElement.id === 'friction-options' && opt.dataset.value === '1') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else {
                    opt.classList.remove('selected');
                    opt.setAttribute('aria-checked', 'false');
                }
            });
            
            // Initialize focus manager
            paletteFocusManager.init();
        }

        function updateXPPreviews() {
            const friction = document.querySelector('#friction-options .selected')?.dataset.value || '1';
            const frictionValue = parseInt(friction);
            
            const xpValues = {
                '15m': Math.round(100 * Math.pow(1 + 15 / 60, 0.5) * frictionValue),
                '30m': Math.round(100 * Math.pow(1 + 30 / 60, 0.5) * frictionValue),
                '1h': Math.round(100 * Math.pow(1 + 60 / 60, 0.5) * frictionValue),
                '4h': Math.round(100 * Math.pow(1 + 240 / 60, 0.5) * frictionValue)
            };
            
            Object.entries(xpValues).forEach(([effort, xp]) => {
                const preview = document.getElementById(`xp-${effort}`);
                if (preview) {
                    preview.textContent = `+${xp} XP`;
                }
            });
        }

        function hidePalette() {
            document.getElementById('palette-modal').classList.add('hidden');
            
            // Clean up focus states
            document.querySelectorAll('.palette-field').forEach(field => {
                field.classList.remove('focused');
                field.removeAttribute('aria-current');
            });
            document.querySelectorAll('.palette-option').forEach(opt => {
                opt.classList.remove('keyboard-focus');
                opt.removeAttribute('aria-selected');
                opt.tabIndex = -1;
            });
        }

        function savePaletteItem() {
            const modal = document.getElementById('palette-modal');
            const mode = modal.dataset.mode || 'task';
            const title = document.getElementById('palette-title').textContent;
            const category = document.querySelector('#category-options .selected')?.dataset.value;
            
            if (mode === 'idea') {
                // Save as idea with minimal data
                const newIdea = {
                    id: `idea_${Date.now()}`,
                    title: title,
                    is_idea: true,
                    is_completed: false,
                    category: category,
                    effort: null,
                    friction: null,
                    due_date: null,
                    completed_at: null,
                    subtasks: []
                };
                
                currentData.ideas.unshift(newIdea);
                saveTodos();
                renderIdeas();
                updateCounts();
                hidePalette();
                showToast('üí° Idea captured!');
            } else {
                // Save as task with full data
                const priority = document.querySelector('#priority-options .selected')?.dataset.value || '2';
                const effort = document.querySelector('#effort-options .selected')?.dataset.value || '30m';
                const friction = document.querySelector('#friction-options .selected')?.dataset.value || '1';
                
                const newTask = {
                    id: `task_${Date.now()}`,
                    title: title,
                    is_idea: false,
                    is_completed: false,
                    category: category,
                    effort: effort,
                    friction: parseInt(friction),
                    subtasks: []
                };
                
                currentData.today.unshift(newTask);
                saveTodos();
                processAndRender();
                hidePalette();
                showToast('Captured ‚úÖ ‚Äî confetti awaits when you tick the box!');
            }
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            const paletteOpen = !document.getElementById('palette-modal').classList.contains('hidden');
            
            if (paletteOpen) {
                const modal = document.getElementById('palette-modal');
                const mode = modal.dataset.mode || 'task';
                paletteFocusManager.isNavigating = true;
                
                if (e.key === 'Escape') {
                    hidePalette();
                } else if (e.key === 'Enter') {
                    savePaletteItem();
                } else if (e.key === 'Tab' && mode === 'idea') {
                    // In idea mode, Tab reveals more options
                    e.preventDefault();
                    ['priority-field', 'effort-field', 'friction-field'].forEach(fieldId => {
                        const field = document.getElementById(fieldId);
                        if (field) field.classList.remove('hidden');
                    });
                    // Update the modal to indicate it's now in full mode
                    document.getElementById('palette-dialog-title').innerHTML = 'üí° Idea with details';
                    modal.querySelector('.keyboard-hints').innerHTML = '<kbd>‚Üë‚Üì</kbd> Navigate fields ¬∑ <kbd>‚Üê‚Üí</kbd> Navigate options ¬∑ <kbd>1-6</kbd> Select ¬∑ <kbd>Space</kbd> Choose';
                    updateXPPreviews();
                } else if (e.key >= '1' && e.key <= '6') {
                    // Number keys select options in current field
                    e.preventDefault();
                    paletteFocusManager.selectByNumber(parseInt(e.key));
                } else if (e.key === 'Tab') {
                    // Tab/Shift+Tab navigate between fields
                    e.preventDefault();
                    paletteFocusManager.navigateFields(e.shiftKey ? -1 : 1);
                } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    // Arrow keys navigate between fields
                    e.preventDefault();
                    paletteFocusManager.navigateFields(e.key === 'ArrowDown' ? 1 : -1);
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    // Left/Right arrows navigate options within field
                    e.preventDefault();
                    paletteFocusManager.navigateOptions(e.key === 'ArrowRight' ? 1 : -1);
                } else if (e.key === ' ') {
                    // Space selects current option
                    e.preventDefault();
                    paletteFocusManager.selectCurrentOption();
                }
                
                paletteFocusManager.isNavigating = false;
                return;
            }
            
            // Global shortcuts
            if (e.key === 'n' || e.key === 'N') {
                const input = document.getElementById('task-input');
                // Only focus if not already focused or if target is not an input
                if (document.activeElement !== input && e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                    input.focus();
                }
            } else if (e.key === 'i' || e.key === 'I') {
                // Quick idea capture using unified palette
                if (document.activeElement.tagName !== 'INPUT' && !paletteOpen) {
                    e.preventDefault();
                    // Show empty input for idea title
                    const input = document.getElementById('task-input');
                    input.placeholder = "What's your idea?";
                    input.dataset.mode = 'idea';
                    input.focus();
                }
            }
        });

        // Input handling
        const taskInput = document.getElementById('task-input');
        taskInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default form submission
                e.stopPropagation(); // Stop event from bubbling up
                
                const value = taskInput.value.trim();
                const mode = taskInput.dataset.mode || 'task';
                
                if (!value) {
                    taskInput.classList.add('error');
                    taskInput.placeholder = 'Need a title first.';
                    setTimeout(() => {
                        taskInput.classList.remove('error');
                        taskInput.placeholder = mode === 'idea' ? "What's your idea?" : "What's on your mind? ‚Ä¶ (press N to add)";
                    }, 1000);
                    return;
                }
                
                showPalette(value, mode);
                taskInput.value = '';
                taskInput.dataset.mode = 'task'; // Reset to default mode
                taskInput.placeholder = "What's on your mind? ‚Ä¶ (press N to add)";
                taskInput.blur();
            } else if (e.key === 'Escape') {
                taskInput.value = '';
                taskInput.dataset.mode = 'task';
                taskInput.placeholder = "What's on your mind? ‚Ä¶ (press N to add)";
                taskInput.blur();
            }
        });

        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                renderTasks();
            });
        });

        // Sort select
        document.getElementById('sort-select').addEventListener('change', (e) => {
            currentSort = e.target.value;
            renderTasks();
        });

        // Palette option clicks
        document.querySelectorAll('.palette-option').forEach(option => {
            option.addEventListener('click', () => {
                const parent = option.parentElement;
                parent.querySelectorAll('.palette-option').forEach(opt => {
                    opt.classList.remove('selected');
                    opt.setAttribute('aria-checked', 'false');
                });
                option.classList.add('selected');
                option.setAttribute('aria-checked', 'true');
                
                if (parent.id === 'friction-options') {
                    updateXPPreviews();
                }
                
                // Update focus manager state when clicking
                const fieldIndex = paletteFocusManager.fields.indexOf(parent.id);
                if (fieldIndex !== -1) {
                    paletteFocusManager.currentFieldIndex = fieldIndex;
                    const options = parent.querySelectorAll('.palette-option');
                    options.forEach((opt, index) => {
                        if (opt === option) {
                            paletteFocusManager.currentOptionIndex = index;
                        }
                    });
                    paletteFocusManager.updateFieldFocus();
                    paletteFocusManager.updateOptionFocus();
                }
            });
        });

        // Modal overlay handling
        document.getElementById('modal-overlay').addEventListener('click', hidePalette);
        document.getElementById('palette-cancel').addEventListener('click', hidePalette);
        document.getElementById('palette-save').addEventListener('click', savePaletteItem);
        
        // Show more button
        document.getElementById('show-more-btn').addEventListener('click', () => {
            showAllTasks = !showAllTasks;
            renderTasks();
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize UI elements
            updateNorthStarSection();
            updateWorkingZone();
            
            initWebSocket();
            loadTodos();
            
            // Restore ideas section collapsed state
            const isCollapsed = localStorage.getItem('ideas-collapsed') === 'true';
            if (isCollapsed) {
                document.getElementById('ideas-section').classList.add('collapsed');
            }
            
            // Setup morphing search functionality
            const searchMorphing = document.getElementById('search-morphing');
            const searchIcon = document.getElementById('search-icon-morph');
            const searchInput = document.getElementById('search-input');
            const searchClear = document.getElementById('search-clear');
            
            // Expand search on icon click
            searchIcon.addEventListener('click', () => {
                searchMorphing.classList.add('active');
                searchInput.focus();
            });
            
            // Handle search input
            searchInput.addEventListener('input', (e) => {
                searchTerm = e.target.value;
                renderTasks();
            });
            
            // Clear search and collapse
            searchClear.addEventListener('click', () => {
                searchTerm = '';
                searchInput.value = '';
                searchMorphing.classList.remove('active');
                renderTasks();
            });
            
            // Hide search on escape
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchTerm = '';
                    searchInput.value = '';
                    searchMorphing.classList.remove('active');
                    renderTasks();
                }
            });
            
            // Collapse on click outside
            document.addEventListener('click', (e) => {
                if (!searchMorphing.contains(e.target) && searchMorphing.classList.contains('active') && !searchInput.value) {
                    searchMorphing.classList.remove('active');
                }
            });
            
            // Prevent input click from bubbling
            searchInput.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        });
        
        // Setup drag and drop on the task list
        setTimeout(() => {
            const taskList = document.getElementById('task-list');
            if (taskList) {
                taskList.addEventListener('dragover', handleDragOver);
                taskList.addEventListener('drop', handleDrop);
            }
        }, 100);
    </script>

</body>
</html>