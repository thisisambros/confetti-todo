<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Confetti Todo</title>
    <link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
    <h1>Confetti Todo</h1>
    
    <div class="app-layout">
        <div class="main-content">
            <!-- North Star Task -->
            <div class="north-star-section" id="north-star-section">
                <div class="north-star-icon">‚≠ê</div>
                <div class="north-star-content">
                    <div class="north-star-label">Today's North Star</div>
                    <div class="north-star-title" id="north-star-title"></div>
                    <div class="north-star-meta">
                        <span id="north-star-category"></span>
                        <span id="north-star-effort"></span>
                        <span class="north-star-xp" id="north-star-xp"></span>
                    </div>
                </div>
                <div class="north-star-actions">
                    <button class="work-btn" id="north-star-work" title="Work on this">‚ñ∂</button>
                    <button class="uncrown-btn" id="north-star-uncrown" title="Remove star">‚úï</button>
                </div>
            </div>
            
            <!-- Working Zone -->
            <div class="working-zone empty" id="working-zone">
                <div class="working-empty">
                    <div class="working-title">Click on a task to start working on it</div>
                    <div>Focus on one thing at a time</div>
                </div>
            </div>
            
            <!-- Input -->
            <div class="input-container">
                <input type="text" id="task-input" placeholder="What's on your mind? ‚Ä¶ (press N to add)">
            </div>

            <!-- Controls -->
            <div class="controls">
                <!-- Date Filter Tabs -->
                <div class="date-filter-tabs">
                    <button class="date-tab active" data-filter="all">
                        <span class="tab-label">All</span>
                        <span class="tab-count" id="count-all">0</span>
                    </button>
                    <button class="date-tab" data-filter="today">
                        <span class="tab-label">Today</span>
                        <span class="tab-count" id="count-today">0</span>
                    </button>
                    <button class="date-tab" data-filter="week">
                        <span class="tab-label">This Week</span>
                        <span class="tab-count" id="count-week">0</span>
                    </button>
                    <button class="date-tab" data-filter="overdue">
                        <span class="tab-label">Overdue</span>
                        <span class="tab-count" id="count-overdue">0</span>
                    </button>
                </div>
                
                <!-- Category Filters and Sort -->
                <div class="filter-row-secondary">
                    <div class="category-filters">
                        <div class="category-chips" id="category-chips">
                            <!-- Active category chips will be inserted here -->
                        </div>
                        <button class="add-category-filter" id="add-category-filter" title="Filter by category">
                            <span class="plus-icon">+</span> Category
                        </button>
                    </div>
                    
                    <select class="sort-select" id="sort-select">
                        <option value="due">Sort: Due Date</option>
                        <option value="xp">Sort: XP Value</option>
                        <option value="effort">Sort: Effort</option>
                        <option value="category">Sort: Category</option>
                    </select>
                </div>
            </div>

            <!-- Tasks -->
            <div class="task-section">
                <div class="section-header">
                    <div class="task-header-left">
                        <span>Tasks (<span id="task-count">0</span>)</span>
                        <span class="task-count-info" id="task-display-info"></span>
                    </div>
                    <div class="search-morphing" id="search-morphing">
                        <div class="search-icon-morph" id="search-icon-morph">üîç</div>
                        <input type="text" class="search-input-morph" id="search-input" placeholder="Start typing...">
                        <div class="search-clear-morph" id="search-clear">‚úï</div>
                    </div>
                </div>
                <ul class="task-list" id="task-list"></ul>
                <button class="show-more-btn hidden" id="show-more-btn">Show More Tasks</button>
                <div class="empty-state hidden" id="empty-state">
                    No tasks yet. Press N to add your first task!
                </div>
            </div>

            <!-- Ideas -->
            <div class="ideas-section" id="ideas-section">
                <div class="ideas-header" onclick="toggleIdeasSection()">
                    <div class="section-header">üí° Ideas (<span id="ideas-count">0</span>)</div>
                    <span class="ideas-toggle">‚ñº</span>
                </div>
                <div id="ideas-list" class="ideas-list"></div>
            </div>
        </div>
        
        <!-- Right Widget -->
        <div class="right-widget">
            <div class="widget-section">
                <div class="widget-title">Level & Progress</div>
                <div class="level-info">
                    Level <span id="current-level">1</span>
                </div>
                <div class="xp-progress-container">
                    <div class="xp-bar">
                        <div class="xp-progress">
                            <div class="xp-fill" id="xp-fill"></div>
                        </div>
                        <span id="xp-text">0/500 XP</span>
                    </div>
                </div>
            </div>
            
            <div class="widget-section">
                <div class="widget-title">Today's Stats</div>
                <div class="today-stats">
                    <div class="stat-item">
                        <span class="stat-value" id="tasks-today">0</span>
                        <span class="stat-label">tasks completed</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="xp-today">0</span>
                        <span class="stat-label">XP earned</span>
                    </div>
                </div>
            </div>
            
            
            <div class="widget-section">
                <div class="widget-title">Energy</div>
                <div class="energy-display">
                    <div class="energy-level">
                        <span id="current-energy">12</span>/<span id="max-energy">12</span>
                    </div>
                    <div class="energy-bar-container">
                        <div class="energy-bar">
                            <div class="energy-fill" id="energy-fill"></div>
                            <div class="energy-threshold-warning"></div>
                            <div class="energy-threshold-suggestion"></div>
                        </div>
                    </div>
                    <div class="energy-status" id="energy-status">Full energy</div>
                    <div class="energy-regeneration" id="energy-regeneration">
                        <div class="regen-timer" id="regen-timer">
                            <span class="regen-icon">‚ö°</span>
                            <span class="regen-text">Next energy in <span id="regen-countdown">15:00</span></span>
                        </div>
                    </div>
                </div>
                <button class="break-button" id="take-break-btn" onclick="showBreakModal()">
                    <span class="coffee-icon">‚òï</span>
                    <span class="break-text">Take a Break</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Palette Modal -->
    <div id="palette-modal" class="hidden" role="dialog" aria-labelledby="palette-dialog-title" aria-modal="true">
        <div class="modal-overlay" id="modal-overlay"></div>
        <div class="palette-modal">
            <div class="palette-title" id="palette-dialog-title">Quick Settings ‚Äî press a number, then Enter</div>
            <div class="sr-only" aria-live="polite">Use arrow keys to navigate between fields, number keys to select options</div>
            <div class="keyboard-hints" style="text-align: center; font-size: 0.9rem; color: var(--color-muted); margin-bottom: 1rem;">
                <kbd>‚Üë‚Üì</kbd> Navigate fields ¬∑ <kbd>‚Üê‚Üí</kbd> Navigate options ¬∑ <kbd>1-6</kbd> Select ¬∑ <kbd>Space</kbd> Choose
            </div>
            
            <div class="palette-field">
                <div class="palette-label">Title: <span id="palette-title"></span></div>
            </div>
            
            <div class="palette-field" id="due-date-field" role="group" aria-labelledby="due-date-label">
                <div class="palette-label" id="due-date-label">Due Date (default ‚òë Today)</div>
                <div class="palette-options" id="due-date-options" role="radiogroup" aria-labelledby="due-date-label">
                    <div class="palette-option selected" data-value="today" role="radio" aria-checked="true"><kbd>1</kbd> Today <span class="date-hint"></span></div>
                    <div class="palette-option" data-value="tomorrow" role="radio" aria-checked="false"><kbd>2</kbd> Tomorrow <span class="date-hint"></span></div>
                    <div class="palette-option" data-value="this-week" role="radio" aria-checked="false"><kbd>3</kbd> This Week <span class="date-hint"></span></div>
                    <div class="palette-option" data-value="no-date" role="radio" aria-checked="false"><kbd>4</kbd> No Due Date</div>
                    <div class="palette-option" data-value="pick-date" role="radio" aria-checked="false"><kbd>5</kbd> Pick Date...</div>
                </div>
                <div class="date-picker-container hidden" id="date-picker-container">
                    <input type="date" id="custom-date-picker" class="date-picker-input" />
                </div>
            </div>
            
            <div class="palette-field" id="category-field" role="group" aria-labelledby="category-label">
                <div class="palette-label" id="category-label">Category (default ‚òë Other)</div>
                <div class="palette-options" id="category-options" role="radiogroup" aria-labelledby="category-label">
                    <div class="palette-option" data-value="admin" role="radio" aria-checked="false"><kbd>1</kbd> Admin</div>
                    <div class="palette-option" data-value="selling" role="radio" aria-checked="false"><kbd>2</kbd> Selling</div>
                    <div class="palette-option" data-value="research" role="radio" aria-checked="false"><kbd>3</kbd> Research</div>
                    <div class="palette-option" data-value="product" role="radio" aria-checked="false"><kbd>4</kbd> Product</div>
                    <div class="palette-option" data-value="hiring" role="radio" aria-checked="false"><kbd>5</kbd> Hiring</div>
                    <div class="palette-option selected" data-value="other" role="radio" aria-checked="true"><kbd>6</kbd> Other</div>
                </div>
            </div>
            
            <div class="palette-field" id="priority-field" role="group" aria-labelledby="priority-label">
                <div class="palette-label" id="priority-label">Priority (default ‚òë Medium)</div>
                <div class="palette-options" id="priority-options" role="radiogroup" aria-labelledby="priority-label">
                    <div class="palette-option" data-value="1" role="radio" aria-checked="false"><kbd>1</kbd> Low</div>
                    <div class="palette-option selected" data-value="2" role="radio" aria-checked="true"><kbd>2</kbd> Medium</div>
                    <div class="palette-option" data-value="3" role="radio" aria-checked="false"><kbd>3</kbd> High</div>
                </div>
            </div>
            
            <div class="palette-field" id="effort-field" role="group" aria-labelledby="effort-label">
                <div class="palette-label" id="effort-label">Effort (default ‚òë 30m)</div>
                <div class="palette-options" id="effort-options" role="radiogroup" aria-labelledby="effort-label">
                    <div class="palette-option" data-value="5m" role="radio" aria-checked="false">
                        <kbd>1</kbd> <5m
                        <div class="xp-preview" id="xp-5m"></div>
                    </div>
                    <div class="palette-option selected" data-value="30m" role="radio" aria-checked="true">
                        <kbd>2</kbd> 30m
                        <div class="xp-preview" id="xp-30m"></div>
                    </div>
                    <div class="palette-option" data-value="1h" role="radio" aria-checked="false">
                        <kbd>3</kbd> 1h
                        <div class="xp-preview" id="xp-1h"></div>
                    </div>
                    <div class="palette-option" data-value="4h" role="radio" aria-checked="false">
                        <kbd>4</kbd> ¬Ω-day
                        <div class="xp-preview" id="xp-4h"></div>
                    </div>
                </div>
            </div>
            
            <div class="palette-field" id="friction-field" role="group" aria-labelledby="friction-label">
                <div class="palette-label" id="friction-label">Friction (default ‚òë üçÉ)</div>
                <div class="palette-options" id="friction-options" role="radiogroup" aria-labelledby="friction-label">
                    <div class="palette-option selected" data-value="1" role="radio" aria-checked="true"><kbd>1</kbd> üçÉ</div>
                    <div class="palette-option" data-value="2" role="radio" aria-checked="false"><kbd>2</kbd> üí®</div>
                    <div class="palette-option" data-value="3" role="radio" aria-checked="false"><kbd>3</kbd> üå™Ô∏è</div>
                </div>
            </div>
            
            <div class="palette-actions">
                <button class="palette-btn" id="palette-save">Enter = Save</button>
                <button class="palette-btn" id="palette-cancel">Esc = Cancel</button>
            </div>
        </div>
    </div>

    <!-- Confetti Container -->
    <div class="confetti-container" id="confetti-container"></div>
    
    <!-- Break Suggestion Modal -->
    <div id="break-modal" class="modal-overlay hidden" onclick="if(event.target === this) closeBreakModal()">
        <div class="break-modal">
            <div class="modal-header">
                <h2>Time for a Break! üåä</h2>
                <button class="modal-close" onclick="closeBreakModal()">‚úï</button>
            </div>
            <div class="modal-body">
                <p class="break-message">You've used <span id="energy-used">8</span> energy. Recharge to maintain peak performance!</p>
                
                <div class="break-options">
                    <button class="break-option" onclick="startBreak(5)">
                        <div class="break-duration">5 min</div>
                        <div class="break-label">Quick Stretch</div>
                        <div class="break-restore">+3 energy</div>
                    </button>
                    <button class="break-option" onclick="startBreak(15)">
                        <div class="break-duration">15 min</div>
                        <div class="break-label">Coffee Break</div>
                        <div class="break-restore">+8 energy</div>
                    </button>
                    <button class="break-option" onclick="startBreak(30)">
                        <div class="break-duration">30 min</div>
                        <div class="break-label">Power Nap</div>
                        <div class="break-restore">Full restore</div>
                    </button>
                </div>
                
                <div class="break-warning hidden" id="break-warning">
                    <span class="warning-icon">‚ö†Ô∏è</span>
                    <span>Energy critically low! A break is highly recommended.</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Break Timer Interface -->
    <div id="break-timer" class="break-timer hidden">
        <div class="break-timer-content">
            <div class="break-timer-header">
                <span class="break-type" id="break-type">Coffee Break</span>
                <button class="break-cancel" onclick="cancelBreak()">‚úï</button>
            </div>
            <div class="break-timer-display" id="break-timer-display">15:00</div>
            <div class="break-progress-bar">
                <div class="break-progress-fill" id="break-progress-fill"></div>
            </div>
            <div class="break-message">Step away from your screen and relax üåø</div>
        </div>
    </div>
    
    <!-- Mobile Bottom Navigation -->
    <nav class="mobile-bottom-nav" id="mobile-bottom-nav">
        <button class="nav-item active" data-filter="all">
            <span class="nav-icon">üìã</span>
            <span class="nav-label">All</span>
            <span class="nav-badge" id="mobile-count-all">0</span>
        </button>
        <button class="nav-item" data-filter="today">
            <span class="nav-icon">üìÖ</span>
            <span class="nav-label">Today</span>
            <span class="nav-badge" id="mobile-count-today">0</span>
        </button>
        <button class="nav-item" id="mobile-add-task">
            <span class="nav-icon nav-icon-add">+</span>
        </button>
        <button class="nav-item" data-filter="week">
            <span class="nav-icon">üìÜ</span>
            <span class="nav-label">Week</span>
            <span class="nav-badge" id="mobile-count-week">0</span>
        </button>
        <button class="nav-item" id="mobile-more-menu">
            <span class="nav-icon">‚ò∞</span>
            <span class="nav-label">More</span>
        </button>
    </nav>
    
    <!-- Mobile Filter Sheet -->
    <div class="mobile-filter-sheet" id="mobile-filter-sheet">
        <div class="sheet-handle"></div>
        <div class="sheet-content">
            <h3>Filters & Sort</h3>
            <div class="mobile-filter-options">
                <div class="mobile-category-section">
                    <h4>Categories</h4>
                    <div class="mobile-category-list" id="mobile-category-list">
                        <!-- Category checkboxes will be inserted here -->
                    </div>
                </div>
                <div class="mobile-sort-section">
                    <h4>Sort By</h4>
                    <select class="mobile-sort-select" id="mobile-sort-select">
                        <option value="due">Due Date</option>
                        <option value="xp">XP Value</option>
                        <option value="effort">Effort</option>
                        <option value="category">Category</option>
                    </select>
                </div>
            </div>
            <button class="sheet-close" id="sheet-close">Done</button>
        </div>
    </div>

    <!-- Main application script -->
    <script>
        // Keep minimal global variables for inline event handlers
        const API_URL = 'http://localhost:8000';
        let ws = null;
        let currentData = { today: [], ideas: [], backlog: [] };
        let allTasks = [];
        let currentFilter = 'all';
        let currentSort = 'due';
        let audioContext = null;
        let activeCategories = new Set();
        let workingTask = null;
        let workingStartTime = null;
        let workingTimer = null;
        let draggedElement = null;
        let showAllTasks = false;
        let expandedTasks = new Set(); // Track which tasks are expanded
        let northStarTask = null; // Today's North Star task
        let searchTerm = ''; // Current search term
        
        // Energy System Variables
        const MAX_ENERGY = 12;
        const ENERGY_WARNING_THRESHOLD = 2;
        const ENERGY_SUGGESTION_THRESHOLD = 4;
        const REGENERATION_INTERVAL = 15 * 60 * 1000; // 15 minutes in milliseconds
        let currentEnergy = MAX_ENERGY;
        let breakTimer = null;
        let breakStartTime = null;
        let breakDuration = null;
        let isOnBreak = false;
        
        // Energy Regeneration Manager
        class RegenerationManager {
            constructor() {
                this.timer = null;
                this.lastRegenTime = Date.now();
                this.isPaused = false;
                this.updateInterval = null;
                this.timeRemaining = REGENERATION_INTERVAL;
            }
            
            init() {
                this.loadState();
                this.start();
                this.updateDisplay();
            }
            
            start() {
                if (this.timer) return;
                
                // Calculate time elapsed since last regen
                const elapsed = Date.now() - this.lastRegenTime;
                
                // Check if we should regenerate multiple points (for accumulated time)
                if (elapsed >= REGENERATION_INTERVAL) {
                    const pointsToRegen = Math.floor(elapsed / REGENERATION_INTERVAL);
                    const actualRegen = Math.min(pointsToRegen, MAX_ENERGY - currentEnergy);
                    
                    if (actualRegen > 0 && !workingTask && !isOnBreak) {
                        restoreEnergy(actualRegen);
                        showToast(`+${actualRegen} energy regenerated! ‚ö°`);
                        // Update last regen time to account for regenerated points
                        this.lastRegenTime = Date.now() - (elapsed % REGENERATION_INTERVAL);
                    }
                }
                
                // Calculate remaining time until next regen
                const timeSinceLastRegen = Date.now() - this.lastRegenTime;
                this.timeRemaining = Math.max(0, REGENERATION_INTERVAL - timeSinceLastRegen);
                
                // Set timer for next regeneration
                this.timer = setTimeout(() => {
                    this.regenerate();
                }, this.timeRemaining);
                
                // Update display every second
                this.updateInterval = setInterval(() => {
                    this.updateDisplay();
                }, 1000);
                
                this.isPaused = false;
                this.updateDisplay();
            }
            
            pause() {
                if (!this.timer) return;
                
                clearTimeout(this.timer);
                clearInterval(this.updateInterval);
                this.timer = null;
                this.updateInterval = null;
                
                // Save remaining time
                const elapsed = Date.now() - this.lastRegenTime;
                this.timeRemaining = Math.max(0, REGENERATION_INTERVAL - elapsed);
                
                this.isPaused = true;
                this.updateDisplay();
                this.saveState();
            }
            
            resume() {
                if (this.timer || !this.isPaused) return;
                
                // Adjust last regen time to account for pause
                this.lastRegenTime = Date.now() - (REGENERATION_INTERVAL - this.timeRemaining);
                this.isPaused = false;
                this.start();
            }
            
            regenerate() {
                if (currentEnergy < MAX_ENERGY && !workingTask && !isOnBreak) {
                    restoreEnergy(1);
                    showToast('+1 energy regenerated! ‚ö°');
                    this.lastRegenTime = Date.now();
                }
                
                // Clear existing timer
                if (this.timer) clearTimeout(this.timer);
                if (this.updateInterval) clearInterval(this.updateInterval);
                this.timer = null;
                this.updateInterval = null;
                
                // Save state
                this.saveState();
                
                // Restart timer for next regeneration
                if (currentEnergy < MAX_ENERGY && !this.isPaused) {
                    this.start();
                }
            }
            
            updateDisplay() {
                const regenTimer = document.getElementById('regen-timer');
                const countdown = document.getElementById('regen-countdown');
                
                if (!regenTimer || !countdown) return;
                
                // Hide timer if at full energy or on break
                if (currentEnergy >= MAX_ENERGY || isOnBreak) {
                    regenTimer.classList.add('hidden');
                    return;
                }
                
                regenTimer.classList.remove('hidden');
                
                // Update paused state
                if (this.isPaused || workingTask) {
                    regenTimer.classList.add('paused');
                    const regenText = regenTimer.querySelector('.regen-text');
                    if (regenText) {
                        regenText.innerHTML = 'Regeneration paused (working)';
                    }
                } else {
                    regenTimer.classList.remove('paused');
                    const regenText = regenTimer.querySelector('.regen-text');
                    if (regenText) {
                        regenText.innerHTML = 'Next energy in <span id="regen-countdown"></span>';
                        const newCountdown = document.getElementById('regen-countdown');
                        if (newCountdown) {
                            // Calculate time remaining
                            const elapsed = Date.now() - this.lastRegenTime;
                            const remaining = Math.max(0, REGENERATION_INTERVAL - elapsed);
                            
                            // If timer reached 0, trigger regeneration
                            if (remaining === 0 && !this.isPaused) {
                                this.regenerate();
                                return;
                            }
                            
                            const minutes = Math.floor(remaining / 60000);
                            const seconds = Math.floor((remaining % 60000) / 1000);
                            newCountdown.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        }
                    }
                }
            }
            
            saveState() {
                const state = {
                    lastRegenTime: this.lastRegenTime,
                    isPaused: this.isPaused,
                    timeRemaining: this.timeRemaining
                };
                localStorage.setItem('regenerationState', JSON.stringify(state));
            }
            
            loadState() {
                try {
                    const saved = localStorage.getItem('regenerationState');
                    if (saved) {
                        const state = JSON.parse(saved);
                        this.lastRegenTime = state.lastRegenTime || Date.now();
                        this.isPaused = state.isPaused || false;
                        this.timeRemaining = state.timeRemaining || REGENERATION_INTERVAL;
                        
                        // Check if we should regenerate points from offline time
                        if (!this.isPaused) {
                            const elapsed = Date.now() - this.lastRegenTime;
                            if (elapsed >= REGENERATION_INTERVAL) {
                                const pointsToRegen = Math.floor(elapsed / REGENERATION_INTERVAL);
                                const actualRegen = Math.min(pointsToRegen, MAX_ENERGY - currentEnergy);
                                
                                if (actualRegen > 0 && !workingTask && !isOnBreak) {
                                    restoreEnergy(actualRegen);
                                    showToast(`Welcome back! +${actualRegen} energy regenerated while you were away! ‚ö°`);
                                    // Update last regen time to account for regenerated points
                                    this.lastRegenTime = Date.now() - (elapsed % REGENERATION_INTERVAL);
                                    this.saveState();
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading regeneration state:', error);
                }
            }
            
            destroy() {
                if (this.timer) clearTimeout(this.timer);
                if (this.updateInterval) clearInterval(this.updateInterval);
                this.timer = null;
                this.updateInterval = null;
            }
        }
        
        // Initialize regeneration manager
        const regenerationManager = new RegenerationManager();
        
        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Format date in European format (DD/MM/YYYY)
        function formatDateEuropean(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        }

        // Focus management for palette
        class PaletteFocusManager {
            constructor() {
                this.fields = ['category-options', 'priority-options', 'effort-options', 'friction-options'];
                this.currentFieldIndex = 0;
                this.currentOptionIndex = 0;
                this.isNavigating = false;
            }

            init() {
                const modal = document.getElementById('palette-modal');
                const mode = modal.dataset.mode || 'task';
                
                // In idea mode, only focus on visible fields
                if (mode === 'idea') {
                    this.fields = ['category-options'];
                    // Add other fields if they become visible
                    if (!document.getElementById('priority-field').classList.contains('hidden')) {
                        this.fields = ['category-options', 'priority-options', 'effort-options', 'friction-options'];
                    }
                } else {
                    this.fields = ['due-date-options', 'category-options', 'priority-options', 'effort-options', 'friction-options'];
                }
                
                this.currentFieldIndex = 0;
                this.currentOptionIndex = this.getSelectedIndex(this.fields[0]) || 0;
                this.updateFieldFocus();
                this.updateOptionFocus();
            }

            navigateFields(direction) {
                this.currentFieldIndex = Math.max(0, Math.min(this.fields.length - 1, this.currentFieldIndex + direction));
                this.currentOptionIndex = this.getSelectedIndex(this.fields[this.currentFieldIndex]) || 0;
                this.updateFieldFocus();
                this.updateOptionFocus();
                this.announceField();
            }

            navigateOptions(direction) {
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                this.currentOptionIndex = Math.max(0, Math.min(options.length - 1, this.currentOptionIndex + direction));
                this.updateOptionFocus();
            }

            selectByNumber(num) {
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                const targetIndex = num - 1; // All fields use 0-based index
                
                if (options[targetIndex]) {
                    this.currentOptionIndex = targetIndex;
                    this.selectCurrentOption();
                    this.updateOptionFocus();
                }
            }

            selectCurrentOption() {
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                
                // Remove selected from all options in this field
                options.forEach(opt => {
                    opt.classList.remove('selected');
                    opt.setAttribute('aria-checked', 'false');
                });
                
                // Add selected to current option
                if (options[this.currentOptionIndex]) {
                    options[this.currentOptionIndex].classList.add('selected');
                    options[this.currentOptionIndex].setAttribute('aria-checked', 'true');
                    
                    // Handle date picker visibility
                    if (this.fields[this.currentFieldIndex] === 'due-date-options') {
                        const selectedValue = options[this.currentOptionIndex].dataset.value;
                        const datePickerContainer = document.getElementById('date-picker-container');
                        const datePicker = document.getElementById('custom-date-picker');
                        
                        if (selectedValue === 'pick-date') {
                            datePickerContainer.classList.remove('hidden');
                            // Set default to today if not set
                            if (!datePicker.value) {
                                datePicker.value = new Date().toISOString().split('T')[0];
                            }
                        } else {
                            datePickerContainer.classList.add('hidden');
                        }
                    }
                    
                    // Update XP previews if friction field
                    if (this.fields[this.currentFieldIndex] === 'friction-options') {
                        updateXPPreviews();
                    }
                }
            }

            getSelectedIndex(fieldId) {
                const field = document.getElementById(fieldId);
                const options = field.querySelectorAll('.palette-option');
                let selectedIndex = 0;
                options.forEach((opt, index) => {
                    if (opt.classList.contains('selected')) {
                        selectedIndex = index;
                    }
                });
                return selectedIndex;
            }

            updateFieldFocus() {
                // Remove all field focus
                document.querySelectorAll('.palette-field').forEach(field => {
                    field.classList.remove('focused');
                    field.removeAttribute('aria-current');
                });

                // Add focus to current field
                const currentFieldElement = document.getElementById(this.fields[this.currentFieldIndex]);
                if (currentFieldElement) {
                    const fieldContainer = currentFieldElement.closest('.palette-field');
                    fieldContainer.classList.add('focused');
                    fieldContainer.setAttribute('aria-current', 'true');
                }
            }

            updateOptionFocus() {
                // Remove all option focus
                document.querySelectorAll('.palette-option').forEach(opt => {
                    opt.classList.remove('keyboard-focus');
                    opt.removeAttribute('aria-selected');
                    opt.tabIndex = -1;
                });

                // Add focus to current option
                const field = document.getElementById(this.fields[this.currentFieldIndex]);
                const options = field.querySelectorAll('.palette-option');
                if (options[this.currentOptionIndex]) {
                    options[this.currentOptionIndex].classList.add('keyboard-focus');
                    options[this.currentOptionIndex].setAttribute('aria-selected', 'true');
                    options[this.currentOptionIndex].tabIndex = 0;
                    // Don't auto-focus to prevent scroll jumping
                    if (this.isNavigating) {
                        options[this.currentOptionIndex].focus({ preventScroll: true });
                    }
                }
            }

            announceField() {
                // For screen readers
                const fieldLabels = {
                    'category-options': 'Category field',
                    'priority-options': 'Priority field',
                    'effort-options': 'Effort field',
                    'friction-options': 'Friction field'
                };
                
                const announcement = document.createElement('div');
                announcement.className = 'sr-only';
                announcement.setAttribute('aria-live', 'polite');
                announcement.textContent = `Now in ${fieldLabels[this.fields[this.currentFieldIndex]]}`;
                document.body.appendChild(announcement);
                setTimeout(() => announcement.remove(), 1000);
            }
        }

        const paletteFocusManager = new PaletteFocusManager();

        // Initialize WebSocket
        function initWebSocket() {
            ws = new WebSocket('ws://localhost:8000/ws');
            
            ws.onopen = () => {
                console.log('WebSocket connected');
            };
            
            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                if (message.type === 'file_changed' || message.type === 'update') {
                    currentData = message.data;
                    processAndRender();
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(initWebSocket, 1000);
            };
        }

        // Fetch initial data
        async function loadTodos() {
            try {
                const response = await fetch(`${API_URL}/api/todos`);
                currentData = await response.json();
                processAndRender();
                
                // Load stats
                await loadStats();
            } catch (error) {
                console.error('Error loading todos:', error);
            }
        }

        // Load stats
        async function loadStats() {
            try {
                const response = await fetch(`${API_URL}/api/stats`);
                const stats = await response.json();
                updateStats(stats);
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        // Process data into flat list
        function processAndRender() {
            allTasks = [];
            
            // Collect all tasks from all sections
            Object.entries(currentData).forEach(([section, tasks]) => {
                tasks.forEach(task => {
                    if (!task.is_idea) {
                        collectTasks(task, section);
                    }
                });
            });
            
            // Render based on current filter and sort
            renderTasks();
            renderIdeas();
            updateCounts();
            
            // Update working task if it exists
            if (workingTask) {
                const updatedTask = allTasks.find(t => t.id === workingTask.id);
                if (updatedTask) {
                    workingTask = updatedTask;
                    updateWorkingZone();
                }
            }
            
            // Restore UI state on initial load
            if (!window.uiStateRestored) {
                window.uiStateRestored = true;
                restoreUIState();
            }
        }

        function collectTasks(task, section, parentTask = null) {
            const taskWithSection = { ...task, section, parentTask };
            allTasks.push(taskWithSection);
            
            if (task.subtasks && task.subtasks.length > 0) {
                task.subtasks.forEach(subtask => {
                    collectTasks(subtask, section, task);
                });
            }
        }

        // Filter tasks
        function filterTasks(tasks) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 7);
            
            // First apply date filter
            let filtered = tasks.filter(task => {
                if (currentFilter === 'all') return true;
                
                if (!task.due_date) return false;
                
                const dueDate = new Date(task.due_date);
                dueDate.setHours(0, 0, 0, 0);
                
                switch (currentFilter) {
                    case 'today':
                        return dueDate.getTime() === today.getTime();
                    case 'week':
                        return dueDate >= weekStart && dueDate < weekEnd;
                    case 'overdue':
                        return dueDate < today && !task.is_completed;
                    default:
                        return true;
                }
            });
            
            // Then apply category filter if any
            if (activeCategories.size > 0) {
                filtered = filtered.filter(task => 
                    activeCategories.has(task.category)
                );
            }
            
            return filtered;
        }
        
        // Update task counts for date tabs
        function updateFilterCounts() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 7);
            
            const counts = {
                all: 0,
                today: 0,
                week: 0,
                overdue: 0
            };
            
            allTasks.forEach(task => {
                if (!task.is_completed) {
                    counts.all++;
                    
                    if (task.due_date) {
                        const dueDate = new Date(task.due_date);
                        dueDate.setHours(0, 0, 0, 0);
                        
                        if (dueDate.getTime() === today.getTime()) {
                            counts.today++;
                        }
                        
                        if (dueDate >= weekStart && dueDate < weekEnd) {
                            counts.week++;
                        }
                        
                        if (dueDate < today) {
                            counts.overdue++;
                        }
                    }
                }
            });
            
            // Update UI
            document.getElementById('count-all').textContent = counts.all;
            document.getElementById('count-today').textContent = counts.today;
            document.getElementById('count-week').textContent = counts.week;
            document.getElementById('count-overdue').textContent = counts.overdue;
        }

        // Sort tasks
        function sortTasks(tasks) {
            return tasks.sort((a, b) => {
                switch (currentSort) {
                    case 'due':
                        if (!a.due_date && !b.due_date) return 0;
                        if (!a.due_date) return 1;
                        if (!b.due_date) return -1;
                        return new Date(a.due_date) - new Date(b.due_date);
                    case 'xp':
                        return calculateXP(b) - calculateXP(a);
                    case 'effort':
                        const effortOrder = { '5m': 1, '15m': 2, '30m': 3, '1h': 4, '4h': 5, '1d': 6 };
                        return (effortOrder[a.effort] || 99) - (effortOrder[b.effort] || 99);
                    case 'category':
                        return (a.category || 'zzz').localeCompare(b.category || 'zzz');
                    default:
                        return 0;
                }
            });
        }

        // Search functionality
        function searchTasks(tasks, searchQuery) {
            const query = searchQuery.toLowerCase().trim();
            if (!query) return tasks;
            
            const matchingTasks = new Set();
            const tasksToReturn = new Set();
            
            // Search through all tasks and subtasks
            function searchInTask(task, parentTask = null) {
                const taskMatches = task.title.toLowerCase().includes(query) || 
                                  (task.category && task.category.toLowerCase().includes(query));
                
                if (taskMatches) {
                    matchingTasks.add(task);
                    // If this is a subtask that matches, include its parent
                    if (parentTask && !parentTask.is_completed) {
                        tasksToReturn.add(parentTask);
                    } else if (!parentTask && !task.is_completed) {
                        // If this is a top-level task that matches, include it
                        tasksToReturn.add(task);
                    }
                }
                
                // Search in subtasks
                if (task.subtasks && task.subtasks.length > 0) {
                    task.subtasks.forEach(subtask => {
                        searchInTask(subtask, task);
                    });
                    
                    // If any subtask matches, include the parent task
                    const hasMatchingSubtask = task.subtasks.some(st => matchingTasks.has(st));
                    if (hasMatchingSubtask && !task.is_completed) {
                        tasksToReturn.add(task);
                    }
                }
            }
            
            // Search through all tasks
            tasks.forEach(task => searchInTask(task));
            
            // Return all matching tasks (both top-level and parents with matching subtasks)
            return Array.from(tasksToReturn);
        }

        // Render tasks
        function renderTasks() {
            const container = document.getElementById('task-list');
            container.innerHTML = '';
            
            // Update filter counts
            updateFilterCounts();
            
            let tasksToDisplay = [];
            
            if (searchTerm) {
                // Search mode: find matching tasks and subtasks
                const searchResults = searchTasks(allTasks, searchTerm);
                tasksToDisplay = searchResults.filter(task => !task.is_completed);
                
                // Always show all results in search mode
                showAllTasks = true;
            } else {
                // Normal mode
                const filteredTasks = filterTasks(allTasks);
                const sortedTasks = sortTasks(filteredTasks);
                tasksToDisplay = sortedTasks.filter(task => !task.parentTask && !task.is_completed);
            }
            
            if (tasksToDisplay.length === 0) {
                const emptyState = document.getElementById('empty-state');
                emptyState.classList.remove('hidden');
                document.getElementById('show-more-btn').classList.add('hidden');
                
                // Customize empty state based on filters
                if (searchTerm) {
                    emptyState.innerHTML = `
                        <div class="empty-filter-state">
                            <div class="empty-icon">üîç</div>
                            <div class="empty-message">No tasks match "${escapeHtml(searchTerm)}"</div>
                            <div class="empty-hint">Try a different search term</div>
                        </div>
                    `;
                } else if (activeCategories.size > 0) {
                    const categoryList = Array.from(activeCategories).map(c => '@' + c).join(', ');
                    emptyState.innerHTML = `
                        <div class="empty-filter-state">
                            <div class="empty-icon">üìÇ</div>
                            <div class="empty-message">No tasks in ${categoryList}</div>
                            <div class="empty-hint">Remove category filters or add tasks to these categories</div>
                        </div>
                    `;
                } else if (currentFilter !== 'all') {
                    const filterMessages = {
                        today: 'No tasks due today',
                        week: 'No tasks due this week',
                        overdue: 'No overdue tasks'
                    };
                    const filterHints = {
                        today: 'Check "This Week" or add tasks with today\'s due date',
                        week: 'Your week is clear! Time to plan ahead',
                        overdue: 'Great job! All tasks are on schedule'
                    };
                    emptyState.innerHTML = `
                        <div class="empty-filter-state">
                            <div class="empty-icon">${currentFilter === 'overdue' ? '‚ú®' : 'üìÖ'}</div>
                            <div class="empty-message">${filterMessages[currentFilter]}</div>
                            <div class="empty-hint">${filterHints[currentFilter]}</div>
                        </div>
                    `;
                } else {
                    // Default empty state
                    emptyState.innerHTML = '<div class="empty-state-text">No active tasks. Press <kbd>N</kbd> to add a task or <kbd>I</kbd> to capture an idea.</div>';
                }
                
                document.getElementById('task-display-info').textContent = '';
            } else {
                document.getElementById('empty-state').classList.add('hidden');
                
                // In search mode, show all; otherwise limit to top 5
                const tasksToShow = (searchTerm || showAllTasks) ? tasksToDisplay : tasksToDisplay.slice(0, 5);
                const hasMore = !searchTerm && tasksToDisplay.length > 5;
                
                tasksToShow.forEach((task, index) => {
                    const element = createTaskElement(task);
                    if (index < 5 && !showAllTasks && !searchTerm) {
                        element.classList.add('top-5');
                    }
                    container.appendChild(element);
                    
                    // Add subtasks if parent is expanded or in search mode
                    if ((expandedTasks.has(task.id) || searchTerm) && task.subtasks && task.subtasks.length > 0) {
                        task.subtasks.forEach(subtask => {
                            const subtaskElement = createTaskElement(subtask, true);
                            subtaskElement.classList.add('visible');
                            container.appendChild(subtaskElement);
                        });
                    }
                });
                
                // Update display info and show more button
                if (searchTerm) {
                    document.getElementById('task-display-info').textContent = `(${tasksToDisplay.length} matching tasks)`;
                    document.getElementById('show-more-btn').classList.add('hidden');
                } else if (hasMore) {
                    const remaining = tasksToDisplay.length - 5;
                    document.getElementById('task-display-info').textContent = 
                        showAllTasks ? `(showing all ${tasksToDisplay.length} tasks)` : `(showing top 5)`;
                    
                    const showMoreBtn = document.getElementById('show-more-btn');
                    showMoreBtn.textContent = showAllTasks ? 'Show Only Top 5' : `Show ${remaining} More Tasks`;
                    showMoreBtn.classList.remove('hidden');
                } else {
                    document.getElementById('task-display-info').textContent = '';
                    document.getElementById('show-more-btn').classList.add('hidden');
                }
            }
        }

        function createTaskElement(task, isSubtask = false) {
            const isMobile = window.innerWidth <= 768;
            
            const li = document.createElement('li');
            li.className = `task-item ${isSubtask ? 'subtask' : ''} ${task.is_completed ? 'completed' : ''}`;
            li.dataset.taskId = task.id;
            
            // Enable drag & drop for non-subtasks on desktop
            if (!isMobile && !isSubtask && !task.is_completed) {
                li.draggable = true;
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragend', handleDragEnd);
            }
            
            // Check if overdue or due today
            if (task.due_date && !task.is_completed) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const dueDate = new Date(task.due_date);
                dueDate.setHours(0, 0, 0, 0);
                
                if (dueDate < today) {
                    li.classList.add('overdue');
                } else if (dueDate.getTime() === today.getTime()) {
                    li.classList.add('due-today');
                }
            }
            
            const checkbox = document.createElement('div');
            checkbox.className = `task-checkbox ${task.is_completed ? 'checked' : ''}`;
            checkbox.onclick = () => toggleTask(task);
            
            const content = document.createElement('div');
            content.className = 'task-content';
            
            const main = document.createElement('div');
            main.className = 'task-main';
            
            const title = document.createElement('div');
            title.className = 'task-title';
            
            // Add subtask toggle if has subtasks (before title text)
            if (task.subtasks && task.subtasks.length > 0 && !isSubtask) {
                const isExpanded = expandedTasks.has(task.id);
                if (isExpanded) {
                    li.classList.add('subtasks-expanded');
                }
                
                const toggle = document.createElement('span');
                toggle.className = 'subtask-toggle';
                toggle.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleSubtasks(li, task);
                };
                title.appendChild(toggle);
            }
            
            const titleText = document.createElement('span');
            titleText.textContent = task.title;
            title.appendChild(titleText);
            
            const meta = document.createElement('div');
            meta.className = 'task-meta';
            
            if (task.category) {
                const category = document.createElement('span');
                category.className = 'task-category';
                category.textContent = `@${task.category}`;
                meta.appendChild(category);
            }
            
            if (task.friction) {
                const friction = document.createElement('span');
                friction.className = 'task-friction';
                const frictionIcons = ['', 'üçÉ', 'üí®', 'üå™Ô∏è'];
                friction.textContent = frictionIcons[task.friction] || 'üçÉ';
                meta.appendChild(friction);
            }
            
            if (task.effort) {
                const effort = document.createElement('span');
                effort.className = 'task-effort';
                effort.textContent = task.effort;
                meta.appendChild(effort);
            }
            
            // Add energy cost indicator
            const energyCost = calculateEnergyCost(task);
            if (energyCost > 0) {
                const energy = document.createElement('span');
                energy.className = 'task-energy-cost';
                energy.textContent = `‚ö°${energyCost}`;
                energy.title = `Requires ${energyCost} energy`;
                meta.appendChild(energy);
            }
            
            if (task.due_date) {
                const due = document.createElement('span');
                due.className = 'task-due';
                const dueDate = new Date(task.due_date);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                if (dueDate < today && !task.is_completed) {
                    due.style.color = 'var(--color-danger)'; // Use dark red for better contrast
                    due.style.fontWeight = '500'; // Make it slightly bolder
                } else if (dueDate.toDateString() === today.toDateString()) {
                    due.style.color = 'var(--color-warning)';
                }
                
                due.textContent = `üìÖ ${formatDateEuropean(task.due_date)}`;
                meta.appendChild(due);
            }
            
            if (task.subtasks && task.subtasks.length > 0) {
                // Create stacked checkbox progress visualization
                const progressContainer = document.createElement('div');
                progressContainer.className = 'task-progress-checkboxes';
                
                // Add has-more class for mobile if more than 3 subtasks
                if (task.subtasks.length > 3) {
                    progressContainer.classList.add('has-more');
                }
                
                const completed = task.subtasks.filter(st => st.is_completed).length;
                const total = task.subtasks.length;
                
                // Create mini checkboxes for each subtask
                task.subtasks.forEach((subtask, index) => {
                    const miniCheckbox = document.createElement('div');
                    miniCheckbox.className = 'mini-checkbox';
                    if (subtask.is_completed) {
                        miniCheckbox.classList.add('completed');
                    }
                    
                    // Add individual tooltip on hover
                    miniCheckbox.setAttribute('title', subtask.title);
                    
                    // Make mini checkboxes clickable to toggle subtask
                    miniCheckbox.style.cursor = 'pointer';
                    miniCheckbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleTask(subtask);
                    });
                    
                    progressContainer.appendChild(miniCheckbox);
                });
                
                // Add hover tooltip with subtask details
                progressContainer.addEventListener('mouseenter', (e) => {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'subtask-tooltip';
                    tooltip.innerHTML = task.subtasks.map((st, idx) => 
                        `<div class="${st.is_completed ? 'completed' : ''}">${st.is_completed ? '‚úì' : '‚óã'} ${escapeHtml(st.title)}</div>`
                    ).join('');
                    
                    document.body.appendChild(tooltip);
                    
                    const rect = progressContainer.getBoundingClientRect();
                    tooltip.style.position = 'absolute';
                    tooltip.style.left = rect.left + 'px';
                    tooltip.style.top = (rect.top - tooltip.offsetHeight - 5) + 'px';
                    
                    progressContainer._tooltip = tooltip;
                });
                
                progressContainer.addEventListener('mouseleave', (e) => {
                    if (progressContainer._tooltip) {
                        progressContainer._tooltip.remove();
                        delete progressContainer._tooltip;
                    }
                });
                
                meta.appendChild(progressContainer);
                
                // Add progress counter
                const progressText = document.createElement('span');
                progressText.className = 'task-progress-counter';
                progressText.textContent = `${completed}/${total}`;
                meta.appendChild(progressText);
            }
            
            main.appendChild(title);
            main.appendChild(meta);
            content.appendChild(main);
            
            // XP display
            const xp = document.createElement('div');
            xp.className = 'task-xp';
            const xpValue = calculateXP(task);
            xp.textContent = `+${xpValue} XP`;
            
            // Show bonus for subtasks
            if (task.subtasks && task.subtasks.length > 0) {
                const completed = task.subtasks.filter(st => st.is_completed).length;
                if (completed === task.subtasks.length && completed > 0) {
                    xp.textContent = `+${Math.round(xpValue * 1.5)} XP ‚ú®`;
                }
            }
            
            content.appendChild(xp);
            
            // Add action buttons for non-completed tasks
            if (!task.is_completed && !isSubtask) {
                const actions = document.createElement('div');
                actions.className = 'task-actions';
                
                const workBtn = document.createElement('button');
                workBtn.className = 'work-btn';
                // Use HTML entities for better compatibility across browsers
                workBtn.innerHTML = workingTask?.id === task.id ? '&#9208;' : '&#9654;';
                workBtn.title = workingTask?.id === task.id ? 'Working' : 'Work on this';
                workBtn.disabled = workingTask?.id === task.id;
                workBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (workingTask) {
                        showSwitchModal(task);
                    } else {
                        startWorkingOn(task);
                    }
                };
                actions.appendChild(workBtn);
                
                // Add crown button if not already crowned
                if (!northStarTask || northStarTask.id !== task.id) {
                    const crownBtn = document.createElement('button');
                    crownBtn.className = 'crown-btn';
                    crownBtn.innerHTML = '‚≠ê';
                    crownBtn.title = 'Set as North Star';
                    crownBtn.onclick = (e) => {
                        e.stopPropagation();
                        setNorthStar(task, !northStarTask); // Only give XP if no North Star is set
                    };
                    actions.appendChild(crownBtn);
                }
                
                // Add subtask button
                const subtaskBtn = document.createElement('button');
                subtaskBtn.className = 'subtask-btn';
                subtaskBtn.textContent = '+ Add Subtask';
                subtaskBtn.onclick = (e) => {
                    e.stopPropagation();
                    showSubtaskInput(task);
                };
                actions.appendChild(subtaskBtn);
                
                content.appendChild(actions);
            }
            
            li.appendChild(checkbox);
            li.appendChild(content);
            
            // Add quick action buttons for mobile
            if (isMobile && !task.is_completed && !isSubtask) {
                const quickActions = document.createElement('div');
                quickActions.className = 'task-quick-actions';
                
                const workBtn = document.createElement('button');
                workBtn.className = 'task-quick-action work';
                workBtn.innerHTML = '‚ñ∂';
                workBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (workingTask && workingTask.id !== task.id) {
                        showSwitchModal(task);
                    } else {
                        startWorkingOn(task);
                    }
                };
                
                const completeBtn = document.createElement('button');
                completeBtn.className = 'task-quick-action complete';
                completeBtn.innerHTML = '‚úì';
                completeBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleTask(task);
                };
                
                quickActions.appendChild(workBtn);
                quickActions.appendChild(completeBtn);
                li.appendChild(quickActions);
            }
            
            return li;
        }

        function renderIdeas() {
            const container = document.getElementById('ideas-list');
            container.innerHTML = '';
            
            const ideas = [];
            Object.entries(currentData).forEach(([section, tasks]) => {
                tasks.forEach(task => {
                    if (task.is_idea) {
                        ideas.push({ ...task, section });
                    }
                });
            });
            
            ideas.forEach(idea => {
                const div = document.createElement('div');
                div.className = 'idea-item';
                div.dataset.ideaId = idea.id;
                div.dataset.section = idea.section;
                
                const text = document.createElement('span');
                text.textContent = `üí° ${idea.title}`;
                if (idea.category) {
                    text.textContent += ` @${idea.category}`;
                }
                div.appendChild(text);
                
                // Create actions container
                const actions = document.createElement('div');
                actions.className = 'idea-actions';
                
                const convertBtn = document.createElement('button');
                convertBtn.className = 'convert-btn';
                convertBtn.textContent = '‚Üí Convert to Task';
                convertBtn.onclick = (e) => {
                    e.stopPropagation();
                    convertIdeaToTask(idea);
                };
                actions.appendChild(convertBtn);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '‚úï Delete';
                deleteBtn.title = 'Delete idea';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteIdea(idea);
                };
                actions.appendChild(deleteBtn);
                
                div.appendChild(actions);
                container.appendChild(div);
            });
        }

        function updateCounts() {
            const taskCount = allTasks.filter(t => !t.is_completed).length;
            document.getElementById('task-count').textContent = taskCount;
            
            let ideasCount = 0;
            Object.values(currentData).forEach(section => {
                section.forEach(task => {
                    if (task.is_idea) ideasCount++;
                });
            });
            document.getElementById('ideas-count').textContent = ideasCount;
        }

        function updateStats(stats) {
            // Update level
            document.getElementById('current-level').textContent = stats.level;
            
            // Update XP bar
            const xpPercent = (stats.xp_progress / stats.xp_for_next_level) * 100;
            document.getElementById('xp-fill').style.width = `${xpPercent}%`;
            document.getElementById('xp-text').textContent = `${stats.xp_progress}/${stats.xp_for_next_level} XP`;
            
            // Update today stats
            document.getElementById('tasks-today').textContent = stats.completed_today;
            document.getElementById('xp-today').textContent = stats.xp_today;
            
        }

        // Working Zone Functions
        function startWorkingOn(task) {
            // Check if user has enough energy
            const energyCost = calculateEnergyCost(task);
            if (currentEnergy < energyCost) {
                showToast(`Not enough energy! You need ${energyCost} energy but have ${currentEnergy}.`);
                showBreakModal();
                return;
            }
            
            // Consume energy when starting work
            consumeEnergy(energyCost);
            
            workingTask = task;
            workingStartTime = new Date();
            updateWorkingZone();
            startWorkingTimer();
            saveUIState();
            
            // Pause regeneration when working
            regenerationManager.pause();
        }
        
        function stopWorking() {
            console.log('stopWorking called', { 
                workingTask: workingTask?.title, 
                workingTimer: !!workingTimer 
            });
            
            if (workingTimer) {
                clearInterval(workingTimer);
                workingTimer = null;
            }
            workingTask = null;
            workingStartTime = null;
            updateWorkingZone();
            saveUIState();
            
            // Resume regeneration when stopping work
            regenerationManager.resume();
        }
        
        function updateWorkingZone() {
            const zone = document.getElementById('working-zone');
            
            if (!workingTask) {
                zone.classList.add('empty');
                zone.innerHTML = `
                    <div class="working-empty">
                        Click on a task to start working on it
                    </div>
                `;
            } else {
                zone.classList.remove('empty');
                const elapsed = workingStartTime ? Math.floor((new Date() - workingStartTime) / 1000) : 0;
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const progressPercent = Math.min((elapsed / (30 * 60)) * 100, 100); // 30 min = 100%
                
                zone.innerHTML = `
                    <div class="working-task">
                        <div class="task-checkbox ${workingTask.is_completed ? 'checked' : ''}" onclick="completeWorkingTask()"></div>
                        <div class="working-content">
                            <div class="working-title">${workingTask.title}</div>
                            <div class="working-meta">
                                ${workingTask.category ? `<span>@${workingTask.category}</span>` : ''}
                                <span>${workingTask.effort || '30m'}</span>
                                <span>${['', 'üçÉ', 'üí®', 'üå™Ô∏è'][workingTask.friction || 2]}</span>
                            </div>
                        </div>
                        <div class="working-timer">
                            ${minutes}:${seconds.toString().padStart(2, '0')}
                        </div>
                        <button class="stop-working-btn" onclick="event.stopPropagation(); stopWorking(); return false;">Stop</button>
                    </div>
                    <div class="working-progress">
                        <div class="working-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                `;
            }
        }
        
        function startWorkingTimer() {
            if (workingTimer) clearInterval(workingTimer);
            workingTimer = setInterval(updateWorkingZone, 1000);
        }
        
        function completeWorkingTask() {
            if (!workingTask) return;
            
            // Mark the task as completed
            toggleTask(workingTask);
            
            // Stop working on it
            stopWorking();
        }
        
        // North Star Task Functions
        function setNorthStar(task, giveXP = true) {
            const isFirstTime = !northStarTask;
            northStarTask = task;
            updateNorthStarSection();
            renderTasks();
            
            if (isFirstTime && giveXP) {
                // Give 25 XP for planning
                showToast(`‚≠ê Great choice! +25 XP for planning your day`);
                // Update stats with bonus XP
                fetch(`${API_URL}/api/stats/bonus`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ xp: 25, reason: 'north_star_set' })
                }).then(() => loadStats());
            } else {
                showToast(`‚≠ê ${task.title} is now your North Star!`);
            }
            
            saveUIState();
        }
        
        function showNorthStarPicker() {
            // Get uncompleted tasks
            const availableTasks = allTasks.filter(t => !t.is_completed && !t.parentTask);
            
            if (availableTasks.length === 0) {
                showToast('No tasks available. Add some tasks first!');
                return;
            }
            
            // Create modal
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const modal = document.createElement('div');
            modal.className = 'north-star-picker-modal';
            modal.innerHTML = `
                <h3>Choose Your North Star Task</h3>
                <p>Select your main focus for today and earn +25 XP!</p>
                <div class="north-star-task-list">
                    ${availableTasks.map(task => `
                        <div class="north-star-option" data-task-id="${task.id}">
                            <div class="task-title">${task.title}</div>
                            <div class="task-meta">
                                ${task.category ? `<span>@${task.category}</span>` : ''}
                                <span>${task.effort || '30m'}</span>
                                <span>${calculateXP(task) * 3} XP (3x bonus)</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <button class="cancel-btn" onclick="closeNorthStarPicker()">Cancel</button>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            // Add click handlers
            modal.querySelectorAll('.north-star-option').forEach(option => {
                option.onclick = () => {
                    const taskId = option.dataset.taskId;
                    const task = allTasks.find(t => t.id === taskId);
                    if (task) {
                        setNorthStar(task);
                        closeNorthStarPicker();
                    }
                };
            });
            
            overlay.onclick = closeNorthStarPicker;
        }
        
        function closeNorthStarPicker() {
            document.querySelector('.modal-overlay')?.remove();
            document.querySelector('.north-star-picker-modal')?.remove();
        }
        
        function removeNorthStar() {
            northStarTask = null;
            updateNorthStarSection();
            renderTasks();
            saveUIState();
        }
        
        function updateNorthStarSection() {
            const section = document.getElementById('north-star-section');
            
            if (!northStarTask) {
                // Show empty state
                const isMobile = window.innerWidth <= 768;
                section.innerHTML = `
                    <div class="north-star-empty-state" ${isMobile ? 'onclick="showNorthStarPicker()"' : ''}>
                        <div class="north-star-icon">‚≠ê</div>
                        <div class="north-star-empty-content">
                            <div class="north-star-empty-title">${isMobile ? 'Choose your main focus today' : 'What\'s your main focus today?'}</div>
                            <button class="choose-north-star-btn" onclick="showNorthStarPicker()">
                                Choose from your tasks ‚ñº
                                <span class="xp-reward">+25 XP</span>
                            </button>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Show selected task
            section.innerHTML = `
                <div class="north-star-icon">‚≠ê</div>
                <div class="north-star-content">
                    <div class="north-star-label">Today's North Star</div>
                    <div class="north-star-title" id="north-star-title">${northStarTask.title}</div>
                    <div class="north-star-meta">
                        <span id="north-star-category">${northStarTask.category ? `@${northStarTask.category}` : ''}</span>
                        <span id="north-star-effort">${northStarTask.effort || '30m'}</span>
                        <span class="north-star-xp" id="north-star-xp"><strong>${calculateXP(northStarTask) * 3} XP ‚Ä¢ 3x bonus</strong></span>
                    </div>
                </div>
                <div class="north-star-actions">
                    <button class="work-btn" id="north-star-work" title="Work on this">${workingTask?.id === northStarTask.id ? '‚è∏' : '‚ñ∂'}</button>
                    <button class="uncrown-btn" id="north-star-uncrown" title="Remove star">‚úï</button>
                </div>
            `;
            
            // Re-attach event listeners
            const workBtn = document.getElementById('north-star-work');
            if (workBtn) {
                workBtn.disabled = workingTask?.id === northStarTask.id;
                workBtn.onclick = () => {
                    if (workingTask && workingTask.id !== northStarTask.id) {
                        showSwitchModal(northStarTask);
                    } else if (!workingTask) {
                        startWorkingOn(northStarTask);
                    }
                };
            }
            
            const uncrownBtn = document.getElementById('north-star-uncrown');
            if (uncrownBtn) {
                uncrownBtn.onclick = removeNorthStar;
            }
        }
        
        // UI State Persistence
        function saveUIState() {
            const uiState = {
                northStarTaskId: northStarTask ? northStarTask.id : null,
                workingTaskId: workingTask ? workingTask.id : null,
                workingStartTime: workingStartTime ? workingStartTime.toISOString() : null
            };
            localStorage.setItem('confettiTodoUIState', JSON.stringify(uiState));
        }
        
        function restoreUIState() {
            try {
                const savedState = localStorage.getItem('confettiTodoUIState');
                if (!savedState) return;
                
                const uiState = JSON.parse(savedState);
                
                // Restore North Star
                if (uiState.northStarTaskId) {
                    const task = findTaskById(uiState.northStarTaskId);
                    if (task && !task.is_completed) {
                        northStarTask = task;
                        updateNorthStarSection();
                    }
                }
                
                // Restore Working Task
                if (uiState.workingTaskId && uiState.workingStartTime) {
                    const task = findTaskById(uiState.workingTaskId);
                    if (task && !task.is_completed) {
                        workingTask = task;
                        workingStartTime = new Date(uiState.workingStartTime);
                        updateWorkingZone();
                        startWorkingTimer();
                    }
                }
            } catch (error) {
                console.error('Error restoring UI state:', error);
            }
        }
        
        function findTaskById(id) {
            // First try to find in allTasks array (if available)
            if (allTasks && allTasks.length > 0) {
                const found = allTasks.find(t => t.id === id);
                if (found) return found;
            }
            
            // Fallback to searching in currentData
            for (const section of Object.values(currentData)) {
                for (const task of section) {
                    if (task.id === id) return task;
                    // Check subtasks
                    if (task.subtasks) {
                        for (const subtask of task.subtasks) {
                            if (subtask.id === id) return subtask;
                        }
                    }
                }
            }
            return null;
        }
        
        function showSwitchModal(newTask) {
            if (!workingTask) return;
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.onclick = cancelSwitch; // Allow clicking overlay to cancel
            
            const modal = document.createElement('div');
            modal.className = 'switch-modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-labelledby', 'switch-modal-title');
            modal.setAttribute('aria-describedby', 'switch-modal-description');
            
            modal.innerHTML = `
                <h3 id="switch-modal-title">Switch Task Confirmation</h3>
                <p id="switch-modal-description">Currently working on: <span class="current-task-name">${escapeHtml(workingTask.title)}</span></p>
                <p>Switch to: <span class="new-task-name">${escapeHtml(newTask.title)}</span>?</p>
                <div class="switch-modal-buttons">
                    <button class="keep-working" onclick="cancelSwitch()" aria-label="Continue working on current task">
                        <span aria-hidden="true">‚Üí</span> Keep Working
                    </button>
                    <button class="switch-task" onclick="confirmSwitch('${newTask.id}')" aria-label="Switch to new task">
                        <span aria-hidden="true">‚ö°</span> Switch Task
                    </button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            // Focus management
            const keepWorkingBtn = modal.querySelector('.keep-working');
            keepWorkingBtn.focus();
            
            // Trap focus within modal
            const focusableElements = modal.querySelectorAll('button');
            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];
            
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    cancelSwitch();
                } else if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            e.preventDefault();
                            lastFocusable.focus();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            e.preventDefault();
                            firstFocusable.focus();
                        }
                    }
                }
            });
        }
        
        window.confirmSwitch = (taskId) => {
            // Remove all modal overlays that are not part of the palette modal
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                if (overlay.id !== 'modal-overlay') {
                    overlay.remove();
                }
            });
            document.querySelector('.switch-modal')?.remove();
            
            const task = allTasks.find(t => t.id === taskId);
            if (task) {
                stopWorking();
                startWorkingOn(task);
            }
        };
        
        window.cancelSwitch = () => {
            // Remove all modal overlays that are not part of the palette modal
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                if (overlay.id !== 'modal-overlay') {
                    overlay.remove();
                }
            });
            document.querySelector('.switch-modal')?.remove();
        };
        
        // Make functions global
        window.stopWorking = stopWorking;
        window.completeWorkingTask = completeWorkingTask;
        window.showNorthStarPicker = showNorthStarPicker;
        window.closeNorthStarPicker = closeNorthStarPicker;
        window.showBreakModal = showBreakModal;
        window.closeBreakModal = closeBreakModal;
        window.startBreak = startBreak;
        window.cancelBreak = cancelBreak;

        async function toggleTask(task) {
            const wasCompleted = task.is_completed;
            task.is_completed = !task.is_completed;
            
            if (task.is_completed) {
                task.completed_at = new Date().toISOString();
                
                // Mark all subtasks as completed too
                if (task.subtasks && task.subtasks.length > 0) {
                    markSubtasksCompleted(task.subtasks, task.completed_at);
                }
                
                showConfetti();
                playSound();
                let xp = calculateXP(task);
                
                // Apply 3x bonus if this is the North Star task
                if (northStarTask && northStarTask.id === task.id) {
                    xp *= 3;
                    showToast(`+${xp} XP ‚Äî North Star completed! üåü`);
                    removeNorthStar(); // Remove North Star after completion
                } else {
                    showToast(`+${xp} XP ‚Äî sweet!`);
                }
            } else {
                task.completed_at = null;
                
                // Optionally, unmark subtasks too when uncompleting parent
                if (task.subtasks && task.subtasks.length > 0) {
                    markSubtasksCompleted(task.subtasks, null, false);
                }
            }
            
            // Update the task in the original data structure
            updateTaskInData(task);
            
            await saveTodos();
            processAndRender();
            await loadStats();
        }
        
        function markSubtasksCompleted(subtasks, completedAt, completed = true) {
            subtasks.forEach(subtask => {
                subtask.is_completed = completed;
                subtask.completed_at = completedAt;
                
                // Recursively mark nested subtasks
                if (subtask.subtasks && subtask.subtasks.length > 0) {
                    markSubtasksCompleted(subtask.subtasks, completedAt, completed);
                }
            });
        }

        function showSubtaskInput(parentTask) {
            // Remove any existing subtask inputs
            document.querySelectorAll('.subtask-input').forEach(input => input.remove());
            
            // Find the parent task element
            const parentElement = document.querySelector(`[data-task-id="${parentTask.id}"]`);
            if (!parentElement) return;
            
            // Create input container
            const inputContainer = document.createElement('div');
            inputContainer.className = 'subtask-input';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Enter subtask title...';
            
            const actions = document.createElement('div');
            actions.className = 'subtask-actions';
            
            const saveBtn = document.createElement('button');
            saveBtn.className = 'save-subtask';
            saveBtn.textContent = 'Add';
            saveBtn.onclick = () => saveSubtask(parentTask, input.value.trim(), inputContainer);
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'cancel-subtask';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => inputContainer.remove();
            
            // Handle Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation();
                    saveSubtask(parentTask, input.value.trim(), inputContainer);
                } else if (e.key === 'Escape') {
                    inputContainer.remove();
                }
            });
            
            actions.appendChild(saveBtn);
            actions.appendChild(cancelBtn);
            inputContainer.appendChild(input);
            inputContainer.appendChild(actions);
            
            // Insert after parent task
            parentElement.parentNode.insertBefore(inputContainer, parentElement.nextSibling);
            input.focus();
        }

        async function saveSubtask(parentTask, title, inputContainer) {
            if (!title) {
                inputContainer.remove();
                return;
            }
            
            // Create new subtask
            const newSubtask = {
                id: `task_${Date.now()}`,
                title: title,
                is_idea: false,
                is_completed: false,
                category: 'other',
                effort: null,
                friction: null,
                due_date: null,
                completed_at: null,
                parent_id: parentTask.id,
                subtasks: []
            };
            
            // Add to parent task's subtasks
            if (!parentTask.subtasks) {
                parentTask.subtasks = [];
            }
            parentTask.subtasks.push(newSubtask);
            
            // Update in data structure
            updateTaskInData(parentTask);
            
            // Ensure the parent task stays expanded to show the new subtask
            expandedTasks.add(parentTask.id);
            
            // Save and refresh
            await saveTodos();
            processAndRender();
            
            // Remove input
            inputContainer.remove();
            
            showToast('Subtask added!');
        }

        function updateTaskInData(updatedTask) {
            Object.entries(currentData).forEach(([section, tasks]) => {
                tasks.forEach((task, index) => {
                    if (task.id === updatedTask.id) {
                        tasks[index] = updatedTask;
                    } else if (task.subtasks) {
                        updateSubtask(task.subtasks, updatedTask);
                    }
                });
            });
        }

        function updateSubtask(subtasks, updatedTask) {
            subtasks.forEach((subtask, index) => {
                if (subtask.id === updatedTask.id) {
                    subtasks[index] = updatedTask;
                } else if (subtask.subtasks) {
                    updateSubtask(subtask.subtasks, updatedTask);
                }
            });
        }

        function calculateXP(task) {
            const effortMap = { '5m': 5, '15m': 15, '30m': 30, '1h': 60, '4h': 240, '1d': 480 };
            const minutes = effortMap[task.effort] || 30;
            const friction = task.friction || 2;
            let xp = Math.round(100 * Math.pow(1 + minutes / 60, 0.5) * friction);
            
            // Bonus for completed subtasks
            if (task.subtasks && task.subtasks.length > 0) {
                const completed = task.subtasks.filter(st => st.is_completed).length;
                if (completed === task.subtasks.length && completed > 0) {
                    xp = Math.round(xp * 1.5);
                }
            }
            
            return xp;
        }
        
        // Energy System Functions
        function calculateEnergyCost(task) {
            const effortMap = { '5m': 1, '15m': 1, '30m': 2, '1h': 4, '4h': 16, '1d': 32 };
            const effortCost = effortMap[task.effort] || 2;
            const friction = task.friction || 1;
            return Math.ceil(effortCost * friction);
        }
        
        function updateEnergyDisplay() {
            const energyFill = document.getElementById('energy-fill');
            const currentEnergyEl = document.getElementById('current-energy');
            const energyStatus = document.getElementById('energy-status');
            const takeBreakBtn = document.getElementById('take-break-btn');
            
            currentEnergyEl.textContent = currentEnergy;
            
            const energyPercent = (currentEnergy / MAX_ENERGY) * 100;
            energyFill.style.width = `${energyPercent}%`;
            
            // Update energy bar color and status
            energyFill.classList.remove('warning', 'critical');
            takeBreakBtn.classList.remove('low-energy');
            
            if (currentEnergy <= ENERGY_WARNING_THRESHOLD) {
                energyFill.classList.add('critical');
                energyStatus.textContent = 'Energy critical!';
                takeBreakBtn.querySelector('.break-text').textContent = 'Take a Break Now!';
                takeBreakBtn.classList.add('low-energy');
            } else if (currentEnergy <= ENERGY_SUGGESTION_THRESHOLD) {
                energyFill.classList.add('warning');
                energyStatus.textContent = 'Consider a break';
                takeBreakBtn.querySelector('.break-text').textContent = 'Take a Break';
                takeBreakBtn.classList.add('low-energy');
            } else {
                energyStatus.textContent = currentEnergy === MAX_ENERGY ? 'Full energy' : 'Good energy';
                takeBreakBtn.querySelector('.break-text').textContent = 'Take a Break';
            }
            
            // Check if we should show break suggestion
            if (!isOnBreak && currentEnergy <= ENERGY_SUGGESTION_THRESHOLD && workingTask) {
                showBreakSuggestion();
            }
            
            // Update regeneration display
            regenerationManager.updateDisplay();
        }
        
        function consumeEnergy(amount) {
            currentEnergy = Math.max(0, currentEnergy - amount);
            updateEnergyDisplay();
            saveEnergyState();
        }
        
        function restoreEnergy(amount) {
            currentEnergy = Math.min(MAX_ENERGY, currentEnergy + amount);
            updateEnergyDisplay();
            saveEnergyState();
        }
        
        function showBreakModal() {
            const modal = document.getElementById('break-modal');
            const energyUsed = document.getElementById('energy-used');
            const breakWarning = document.getElementById('break-warning');
            
            energyUsed.textContent = MAX_ENERGY - currentEnergy;
            
            if (currentEnergy <= ENERGY_WARNING_THRESHOLD) {
                breakWarning.classList.remove('hidden');
            } else {
                breakWarning.classList.add('hidden');
            }
            
            modal.classList.remove('hidden');
        }
        
        function closeBreakModal() {
            document.getElementById('break-modal').classList.add('hidden');
        }
        
        function showBreakSuggestion() {
            // Don't show if already shown recently
            const lastSuggestion = localStorage.getItem('lastBreakSuggestion');
            const now = Date.now();
            if (lastSuggestion && now - parseInt(lastSuggestion) < 300000) return; // 5 minutes
            
            localStorage.setItem('lastBreakSuggestion', now);
            showBreakModal();
        }
        
        function startBreak(minutes) {
            closeBreakModal();
            
            isOnBreak = true;
            breakDuration = minutes * 60; // Convert to seconds
            breakStartTime = Date.now();
            
            // Stop working if in progress
            if (workingTask) {
                stopWorking();
            }
            
            // Pause regeneration during break
            regenerationManager.pause();
            
            // Show break timer
            const breakTimerEl = document.getElementById('break-timer');
            const breakType = document.getElementById('break-type');
            
            if (minutes === 5) {
                breakType.textContent = 'Quick Stretch';
            } else if (minutes === 15) {
                breakType.textContent = 'Coffee Break';
            } else {
                breakType.textContent = 'Power Nap';
            }
            
            breakTimerEl.classList.remove('hidden');
            updateBreakTimer();
            
            // Start timer interval
            if (breakTimer) clearInterval(breakTimer);
            breakTimer = setInterval(updateBreakTimer, 1000);
        }
        
        function updateBreakTimer() {
            const elapsed = Math.floor((Date.now() - breakStartTime) / 1000);
            const remaining = Math.max(0, breakDuration - elapsed);
            
            const minutes = Math.floor(remaining / 60);
            const seconds = remaining % 60;
            
            const display = document.getElementById('break-timer-display');
            display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            const progressFill = document.getElementById('break-progress-fill');
            const progress = ((breakDuration - remaining) / breakDuration) * 100;
            progressFill.style.width = `${progress}%`;
            
            if (remaining === 0) {
                completeBreak();
            }
        }
        
        function completeBreak() {
            cancelBreak();
            
            // Restore energy based on break duration
            let restoredEnergy;
            if (breakDuration === 300) { // 5 minutes
                restoredEnergy = 3;
            } else if (breakDuration === 900) { // 15 minutes
                restoredEnergy = 8;
            } else { // 30 minutes
                currentEnergy = MAX_ENERGY;
                updateEnergyDisplay();
                showToast('Fully recharged! üîã');
                return;
            }
            
            restoreEnergy(restoredEnergy);
            showToast(`+${restoredEnergy} energy restored! üåü`);
        }
        
        function cancelBreak() {
            isOnBreak = false;
            if (breakTimer) {
                clearInterval(breakTimer);
                breakTimer = null;
            }
            
            breakStartTime = null;
            breakDuration = null;
            
            document.getElementById('break-timer').classList.add('hidden');
            
            // Resume regeneration after break
            regenerationManager.resume();
        }
        
        function saveEnergyState() {
            const energyState = {
                currentEnergy,
                lastUpdated: Date.now()
            };
            localStorage.setItem('energyState', JSON.stringify(energyState));
        }
        
        function loadEnergyState() {
            try {
                const saved = localStorage.getItem('energyState');
                if (saved) {
                    const state = JSON.parse(saved);
                    // Check if it's a new day
                    const lastUpdate = new Date(state.lastUpdated);
                    const today = new Date();
                    if (lastUpdate.toDateString() !== today.toDateString()) {
                        // New day, reset energy
                        currentEnergy = MAX_ENERGY;
                    } else {
                        currentEnergy = state.currentEnergy;
                    }
                }
            } catch (error) {
                console.error('Error loading energy state:', error);
            }
            updateEnergyDisplay();
        }

        function showConfetti() {
            const container = document.getElementById('confetti-container');
            container.innerHTML = '';
            
            for (let i = 0; i < 120; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.style.left = `${Math.random() * 100}%`;
                piece.style.top = `${Math.random() * 100 - 50}%`;
                piece.style.background = ['#0043ff', '#89efbd', '#ffd6d8', '#ffeb3b', '#e91e63'][Math.floor(Math.random() * 5)];
                piece.style.animationDelay = `${Math.random() * 0.3}s`;
                container.appendChild(piece);
                
                setTimeout(() => piece.remove(), 800);
            }
        }

        function playSound() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        
        function convertIdeaToTask(idea) {
            const ideaElement = document.querySelector(`[data-idea-id="${idea.id}"]`);
            if (ideaElement) {
                ideaElement.classList.add('converting');
            }
            
            // Remove from ideas
            const section = idea.section;
            const index = currentData[section].findIndex(i => i.id === idea.id);
            if (index > -1) {
                currentData[section].splice(index, 1);
            }
            
            // Convert to task
            const task = {
                ...idea,
                is_idea: false,
                effort: '30m',
                friction: 2
            };
            
            // Add to today section
            currentData.today.unshift(task);
            
            setTimeout(() => {
                saveTodos();
                renderTasks();
                renderIdeas();
                updateCounts();
                showCelebrationToast('üå± Idea sprouted into task!');
            }, 600);
        }
        
        function deleteIdea(idea) {
            // Add confirmation
            if (!confirm(`Delete idea "${idea.title}"?`)) {
                return;
            }
            
            // Remove from data
            const section = idea.section;
            const index = currentData[section].findIndex(i => i.id === idea.id);
            if (index > -1) {
                currentData[section].splice(index, 1);
            }
            
            // Update UI
            saveTodos();
            renderIdeas();
            updateCounts();
            
            showToast('üóëÔ∏è Idea deleted');
        }
        
        function toggleIdeasSection() {
            const section = document.getElementById('ideas-section');
            section.classList.toggle('collapsed');
            
            // Save preference
            localStorage.setItem('ideas-collapsed', section.classList.contains('collapsed'));
        }
        
        function showCelebrationToast(message) {
            // Remove any existing celebration toasts
            document.querySelectorAll('.celebration-toast').forEach(t => t.remove());
            
            const toast = document.createElement('div');
            toast.className = 'celebration-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.remove(), 3000);
        }
        
        // Drag & Drop Functions
        function handleDragStart(e) {
            draggedElement = e.target.closest('.task-item');
            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', '');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            if (!draggedElement) return;
            
            const container = document.getElementById('task-list');
            const afterElement = getDragAfterElement(container, e.clientY);
            
            if (afterElement == null) {
                container.appendChild(draggedElement);
            } else {
                container.insertBefore(draggedElement, afterElement);
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
            updateTaskOrder();
        }
        
        function handleDragEnd(e) {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
            }
            draggedElement = null;
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging):not(.subtask)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        function updateTaskOrder() {
            // Get current order from DOM
            const taskList = document.getElementById('task-list');
            const orderedIds = [...taskList.querySelectorAll('.task-item:not(.subtask)')]
                .map(el => el.dataset.taskId);
            
            // Reorder tasks in currentData based on DOM order
            const reorderedToday = [];
            orderedIds.forEach(id => {
                const task = currentData.today.find(t => t.id === id);
                if (task) reorderedToday.push(task);
            });
            
            // Keep any remaining tasks that weren't in the DOM
            currentData.today.forEach(task => {
                if (!reorderedToday.find(t => t.id === task.id)) {
                    reorderedToday.push(task);
                }
            });
            
            currentData.today = reorderedToday;
            saveTodos();
        }
        
        // Toggle subtasks
        function toggleSubtasks(element, task) {
            if (expandedTasks.has(task.id)) {
                expandedTasks.delete(task.id);
            } else {
                expandedTasks.add(task.id);
            }
            renderTasks();
        }

        // Save todos
        async function saveTodos() {
            try {
                const response = await fetch(`${API_URL}/api/todos`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currentData)
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Server error:', errorData);
                    showToast('Failed to save task. Please try again.', 'error');
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error('Error saving todos:', error);
                showToast('Failed to save task. Please check your connection.', 'error');
            }
        }

        // Palette handling
        function showPalette(title, mode = 'task') {
            const modal = document.getElementById('palette-modal');
            modal.dataset.mode = mode;
            
            document.getElementById('palette-title').textContent = title;
            modal.classList.remove('hidden');
            
            // Update modal title and hints based on mode
            const dialogTitle = document.getElementById('palette-dialog-title');
            const keyboardHints = modal.querySelector('.keyboard-hints');
            
            if (mode === 'idea') {
                dialogTitle.innerHTML = 'üí° Capture an idea ‚Äî low commitment';
                keyboardHints.innerHTML = '<kbd>Enter</kbd> Save ¬∑ <kbd>Tab</kbd> More options ¬∑ <kbd>Esc</kbd> Cancel';
                
                // Hide non-essential fields for ideas
                ['due-date-field', 'priority-field', 'effort-field', 'friction-field'].forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) field.classList.add('hidden');
                });
                
                // Show simpler action buttons
                document.getElementById('palette-save').textContent = 'Enter = Capture Idea';
            } else {
                dialogTitle.innerHTML = '‚ö° Quick Settings ‚Äî press a number, then Enter';
                keyboardHints.innerHTML = '<kbd>‚Üë‚Üì</kbd> Navigate fields ¬∑ <kbd>‚Üê‚Üí</kbd> Navigate options ¬∑ <kbd>1-6</kbd> Select ¬∑ <kbd>Space</kbd> Choose';
                
                // Show all fields for tasks
                ['due-date-field', 'priority-field', 'effort-field', 'friction-field'].forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) field.classList.remove('hidden');
                });
                
                document.getElementById('palette-save').textContent = 'Enter = Save Task';
                updateXPPreviews();
            }
            
            // Reset selections
            document.querySelectorAll('.palette-option').forEach(opt => {
                if (opt.parentElement.id === 'category-options' && opt.dataset.value === 'other') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else if (opt.parentElement.id === 'priority-options' && opt.dataset.value === '2') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else if (opt.parentElement.id === 'effort-options' && opt.dataset.value === '30m') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else if (opt.parentElement.id === 'friction-options' && opt.dataset.value === '1') {
                    opt.classList.add('selected');
                    opt.setAttribute('aria-checked', 'true');
                } else {
                    opt.classList.remove('selected');
                    opt.setAttribute('aria-checked', 'false');
                }
            });
            
            // Ensure date field has Today selected by default (only if nothing selected)
            const dueDateSelected = document.querySelector('#due-date-options .selected');
            if (!dueDateSelected) {
                const todayOption = document.querySelector('#due-date-options .palette-option[data-value="today"]');
                if (todayOption) {
                    todayOption.classList.add('selected');
                    todayOption.setAttribute('aria-checked', 'true');
                }
            }
            
            // Update date hints with European format
            const updateDateHints = () => {
                const today = new Date();
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                const endOfWeek = new Date();
                const daysUntilSunday = 7 - endOfWeek.getDay();
                endOfWeek.setDate(endOfWeek.getDate() + daysUntilSunday);
                
                const todayHint = document.querySelector('[data-value="today"] .date-hint');
                const tomorrowHint = document.querySelector('[data-value="tomorrow"] .date-hint');
                const weekHint = document.querySelector('[data-value="this-week"] .date-hint');
                
                if (todayHint) todayHint.textContent = `(${formatDateEuropean(today.toISOString())})`;
                if (tomorrowHint) tomorrowHint.textContent = `(${formatDateEuropean(tomorrow.toISOString())})`;
                if (weekHint) weekHint.textContent = `(${formatDateEuropean(endOfWeek.toISOString())})`;
            };
            
            updateDateHints();
            
            // Initialize focus manager
            paletteFocusManager.init();
        }

        function updateXPPreviews() {
            const friction = document.querySelector('#friction-options .selected')?.dataset.value || '1';
            const frictionValue = parseInt(friction);
            
            const xpValues = {
                '5m': Math.round(100 * Math.pow(1 + 5 / 60, 0.5) * frictionValue),
                '15m': Math.round(100 * Math.pow(1 + 15 / 60, 0.5) * frictionValue),
                '30m': Math.round(100 * Math.pow(1 + 30 / 60, 0.5) * frictionValue),
                '1h': Math.round(100 * Math.pow(1 + 60 / 60, 0.5) * frictionValue),
                '4h': Math.round(100 * Math.pow(1 + 240 / 60, 0.5) * frictionValue)
            };
            
            Object.entries(xpValues).forEach(([effort, xp]) => {
                const preview = document.getElementById(`xp-${effort}`);
                if (preview) {
                    preview.textContent = `+${xp} XP`;
                }
            });
        }

        function hidePalette() {
            document.getElementById('palette-modal').classList.add('hidden');
            
            // Clean up focus states
            document.querySelectorAll('.palette-field').forEach(field => {
                field.classList.remove('focused');
                field.removeAttribute('aria-current');
            });
            document.querySelectorAll('.palette-option').forEach(opt => {
                opt.classList.remove('keyboard-focus');
                opt.removeAttribute('aria-selected');
                opt.tabIndex = -1;
            });
        }

        function savePaletteItem() {
            const modal = document.getElementById('palette-modal');
            const mode = modal.dataset.mode || 'task';
            const title = document.getElementById('palette-title').textContent;
            const category = document.querySelector('#category-options .selected')?.dataset.value;
            
            if (mode === 'idea') {
                // Save as idea with minimal data
                const newIdea = {
                    id: `idea_${Date.now()}`,
                    title: title,
                    is_idea: true,
                    is_completed: false,
                    category: category,
                    effort: null,
                    friction: null,
                    due_date: null,
                    completed_at: null,
                    subtasks: []
                };
                
                currentData.ideas.unshift(newIdea);
                saveTodos();
                renderIdeas();
                updateCounts();
                hidePalette();
                showToast('üí° Idea captured!');
            } else {
                // Save as task with full data
                const priority = document.querySelector('#priority-options .selected')?.dataset.value || '2';
                const effort = document.querySelector('#effort-options .selected')?.dataset.value || '30m';
                const friction = document.querySelector('#friction-options .selected')?.dataset.value || '1';
                
                // Calculate due date based on selection
                const dueDateValue = document.querySelector('#due-date-options .selected')?.dataset.value || 'today';
                let dueDate = null;
                
                if (dueDateValue === 'today') {
                    dueDate = new Date().toISOString().split('T')[0];
                } else if (dueDateValue === 'tomorrow') {
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    dueDate = tomorrow.toISOString().split('T')[0];
                } else if (dueDateValue === 'this-week') {
                    const endOfWeek = new Date();
                    const daysUntilSunday = 7 - endOfWeek.getDay();
                    endOfWeek.setDate(endOfWeek.getDate() + daysUntilSunday);
                    dueDate = endOfWeek.toISOString().split('T')[0];
                } else if (dueDateValue === 'pick-date') {
                    const customDate = document.getElementById('custom-date-picker').value;
                    dueDate = customDate || null;
                } else if (dueDateValue === 'no-date') {
                    dueDate = null;
                }
                
                const newTask = {
                    id: `task_${Date.now()}`,
                    title: title,
                    is_idea: false,
                    is_completed: false,
                    category: category,
                    effort: effort,
                    friction: parseInt(friction),
                    due_date: dueDate,
                    completed_at: null,
                    subtasks: []
                };
                
                currentData.today.unshift(newTask);
                saveTodos();
                processAndRender();
                hidePalette();
                showToast('Captured ‚úÖ ‚Äî confetti awaits when you tick the box!');
            }
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            const paletteOpen = !document.getElementById('palette-modal').classList.contains('hidden');
            
            if (paletteOpen) {
                const modal = document.getElementById('palette-modal');
                const mode = modal.dataset.mode || 'task';
                paletteFocusManager.isNavigating = true;
                
                if (e.key === 'Escape') {
                    hidePalette();
                } else if (e.key === 'Enter') {
                    savePaletteItem();
                } else if (e.key === 'Tab' && mode === 'idea') {
                    // In idea mode, Tab reveals more options
                    e.preventDefault();
                    ['due-date-field', 'priority-field', 'effort-field', 'friction-field'].forEach(fieldId => {
                        const field = document.getElementById(fieldId);
                        if (field) field.classList.remove('hidden');
                    });
                    // Update the modal to indicate it's now in full mode
                    document.getElementById('palette-dialog-title').innerHTML = 'üí° Idea with details';
                    modal.querySelector('.keyboard-hints').innerHTML = '<kbd>‚Üë‚Üì</kbd> Navigate fields ¬∑ <kbd>‚Üê‚Üí</kbd> Navigate options ¬∑ <kbd>1-6</kbd> Select ¬∑ <kbd>Space</kbd> Choose';
                    updateXPPreviews();
                } else if (e.key >= '1' && e.key <= '6') {
                    // Number keys select options in current field
                    e.preventDefault();
                    paletteFocusManager.selectByNumber(parseInt(e.key));
                } else if (e.key === 'Tab') {
                    // Tab/Shift+Tab navigate between fields
                    e.preventDefault();
                    paletteFocusManager.navigateFields(e.shiftKey ? -1 : 1);
                } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    // Arrow keys navigate between fields
                    e.preventDefault();
                    paletteFocusManager.navigateFields(e.key === 'ArrowDown' ? 1 : -1);
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    // Left/Right arrows navigate options within field
                    e.preventDefault();
                    paletteFocusManager.navigateOptions(e.key === 'ArrowRight' ? 1 : -1);
                } else if (e.key === ' ') {
                    // Space selects current option
                    e.preventDefault();
                    paletteFocusManager.selectCurrentOption();
                }
                
                paletteFocusManager.isNavigating = false;
                return;
            }
            
            // Global shortcuts
            if (e.key === 'n' || e.key === 'N') {
                const input = document.getElementById('task-input');
                // Only focus if not already focused or if target is not an input
                if (document.activeElement !== input && e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                    input.focus();
                }
            } else if (e.key === 'i' || e.key === 'I') {
                // Quick idea capture using unified palette
                if (document.activeElement.tagName !== 'INPUT' && !paletteOpen) {
                    e.preventDefault();
                    // Show empty input for idea title
                    const input = document.getElementById('task-input');
                    input.placeholder = "What's your idea?";
                    input.dataset.mode = 'idea';
                    input.focus();
                }
            }
        });

        // Input handling
        const taskInput = document.getElementById('task-input');
        taskInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default form submission
                e.stopPropagation(); // Stop event from bubbling up
                
                const value = taskInput.value.trim();
                const mode = taskInput.dataset.mode || 'task';
                
                if (!value) {
                    taskInput.classList.add('error');
                    taskInput.placeholder = 'Need a title first.';
                    setTimeout(() => {
                        taskInput.classList.remove('error');
                        taskInput.placeholder = mode === 'idea' ? "What's your idea?" : "What's on your mind? ‚Ä¶ (press N to add)";
                    }, 1000);
                    return;
                }
                
                showPalette(value, mode);
                taskInput.value = '';
                taskInput.dataset.mode = 'task'; // Reset to default mode
                taskInput.placeholder = "What's on your mind? ‚Ä¶ (press N to add)";
                taskInput.blur();
            } else if (e.key === 'Escape') {
                taskInput.value = '';
                taskInput.dataset.mode = 'task';
                taskInput.placeholder = "What's on your mind? ‚Ä¶ (press N to add)";
                taskInput.blur();
            }
        });

        // New date filter tabs
        document.querySelectorAll('.date-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.date-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentFilter = tab.dataset.filter;
                renderTasks();
            });
        });
        
        // Category filter system
        
        // Add category filter button
        const addCategoryBtn = document.getElementById('add-category-filter');
        const categoryChips = document.getElementById('category-chips');
        
        addCategoryBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showCategorySelector(e.target);
        });
        
        function showCategorySelector(anchor) {
            // Remove any existing popup
            const existing = document.querySelector('.category-selector-popup');
            if (existing) existing.remove();
            
            const popup = document.createElement('div');
            popup.className = 'category-selector-popup';
            
            const categories = ['admin', 'selling', 'research', 'product', 'hiring', 'other'];
            categories.forEach(cat => {
                if (!activeCategories.has(cat)) {
                    const option = document.createElement('button');
                    option.className = 'category-option';
                    option.textContent = '@' + cat;
                    option.addEventListener('click', () => {
                        addCategoryFilter(cat);
                        popup.remove();
                    });
                    popup.appendChild(option);
                }
            });
            
            // Position relative to button
            const rect = anchor.getBoundingClientRect();
            popup.style.position = 'fixed';
            popup.style.left = rect.left + 'px';
            popup.style.top = rect.bottom + 'px';
            
            document.body.appendChild(popup);
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        document.removeEventListener('click', closePopup);
                    }
                });
            }, 0);
        }
        
        function addCategoryFilter(category) {
            activeCategories.add(category);
            
            const chip = document.createElement('div');
            chip.className = 'category-chip';
            chip.innerHTML = `
                <span class="chip-label">@${category}</span>
                <button class="remove-chip" title="Remove filter">√ó</button>
            `;
            
            chip.querySelector('.remove-chip').addEventListener('click', () => {
                activeCategories.delete(category);
                chip.remove();
                renderTasks();
                
                // Show add button if no filters
                if (activeCategories.size === 0) {
                    addCategoryBtn.style.display = 'inline-flex';
                }
            });
            
            categoryChips.appendChild(chip);
            
            // Hide add button if we have max categories
            if (activeCategories.size >= 6) {
                addCategoryBtn.style.display = 'none';
            }
            
            renderTasks();
        }

        // Sort select
        document.getElementById('sort-select').addEventListener('change', (e) => {
            currentSort = e.target.value;
            renderTasks();
        });

        // Palette option clicks
        document.querySelectorAll('.palette-option').forEach(option => {
            option.addEventListener('click', () => {
                const parent = option.parentElement;
                parent.querySelectorAll('.palette-option').forEach(opt => {
                    opt.classList.remove('selected');
                    opt.setAttribute('aria-checked', 'false');
                });
                option.classList.add('selected');
                option.setAttribute('aria-checked', 'true');
                
                if (parent.id === 'friction-options') {
                    updateXPPreviews();
                }
                
                // Update focus manager state when clicking
                const fieldIndex = paletteFocusManager.fields.indexOf(parent.id);
                if (fieldIndex !== -1) {
                    paletteFocusManager.currentFieldIndex = fieldIndex;
                    const options = parent.querySelectorAll('.palette-option');
                    options.forEach((opt, index) => {
                        if (opt === option) {
                            paletteFocusManager.currentOptionIndex = index;
                        }
                    });
                    paletteFocusManager.updateFieldFocus();
                    paletteFocusManager.updateOptionFocus();
                }
            });
        });

        // Modal overlay handling
        document.getElementById('modal-overlay').addEventListener('click', hidePalette);
        document.getElementById('palette-cancel').addEventListener('click', hidePalette);
        document.getElementById('palette-save').addEventListener('click', savePaletteItem);
        
        // Show more button
        document.getElementById('show-more-btn').addEventListener('click', () => {
            showAllTasks = !showAllTasks;
            renderTasks();
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize UI elements
            updateNorthStarSection();
            updateWorkingZone();
            
            // Initialize Energy System
            loadEnergyState();
            regenerationManager.init();
            
            initWebSocket();
            loadTodos();
            
            // Restore ideas section collapsed state
            const isCollapsed = localStorage.getItem('ideas-collapsed') === 'true';
            if (isCollapsed) {
                document.getElementById('ideas-section').classList.add('collapsed');
            }
            
            // Setup morphing search functionality
            const searchMorphing = document.getElementById('search-morphing');
            const searchIcon = document.getElementById('search-icon-morph');
            const searchInput = document.getElementById('search-input');
            const searchClear = document.getElementById('search-clear');
            
            // Expand search on icon click
            searchIcon.addEventListener('click', () => {
                searchMorphing.classList.add('active');
                searchInput.focus();
            });
            
            // Handle search input
            searchInput.addEventListener('input', (e) => {
                searchTerm = e.target.value;
                renderTasks();
            });
            
            // Clear search and collapse
            searchClear.addEventListener('click', () => {
                searchTerm = '';
                searchInput.value = '';
                searchMorphing.classList.remove('active');
                renderTasks();
            });
            
            // Hide search on escape
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchTerm = '';
                    searchInput.value = '';
                    searchMorphing.classList.remove('active');
                    renderTasks();
                }
            });
            
            // Collapse on click outside
            document.addEventListener('click', (e) => {
                if (!searchMorphing.contains(e.target) && searchMorphing.classList.contains('active') && !searchInput.value) {
                    searchMorphing.classList.remove('active');
                }
            });
            
            // Prevent input click from bubbling
            searchInput.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        });
        
        // Setup drag and drop on the task list
        setTimeout(() => {
            const taskList = document.getElementById('task-list');
            if (taskList) {
                taskList.addEventListener('dragover', handleDragOver);
                taskList.addEventListener('drop', handleDrop);
            }
        }, 100);
        
        // Mobile-specific functionality
        function initializeMobile() {
            if (window.innerWidth > 768) return;
            
            // Mobile bottom navigation
            const mobileNavItems = document.querySelectorAll('.mobile-bottom-nav .nav-item[data-filter]');
            mobileNavItems.forEach(item => {
                item.addEventListener('click', () => {
                    // Update active state
                    mobileNavItems.forEach(nav => nav.classList.remove('active'));
                    item.classList.add('active');
                    
                    // Update filter
                    currentFilter = item.dataset.filter;
                    
                    // Sync with desktop tabs if they exist
                    const desktopTab = document.querySelector(`.date-tab[data-filter="${currentFilter}"]`);
                    if (desktopTab) {
                        document.querySelectorAll('.date-tab').forEach(t => t.classList.remove('active'));
                        desktopTab.classList.add('active');
                    }
                    
                    renderTasks();
                });
            });
            
            // Add task button
            const mobileAddBtn = document.getElementById('mobile-add-task');
            mobileAddBtn.addEventListener('click', () => {
                // Create mobile task input
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'mobile-task-input';
                input.placeholder = 'What needs to be done?';
                input.style.cssText = `
                    position: fixed;
                    bottom: 70px;
                    left: 10px;
                    right: 10px;
                    padding: 1rem;
                    font-size: 16px;
                    border: 2px solid var(--color-primary);
                    border-radius: 8px;
                    background: white;
                    z-index: 1001;
                    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                `;
                
                document.body.appendChild(input);
                input.focus();
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && input.value.trim()) {
                        showPalette(input.value.trim(), 'task');
                        input.remove();
                    } else if (e.key === 'Escape') {
                        input.remove();
                    }
                });
                
                input.addEventListener('blur', () => {
                    setTimeout(() => input.remove(), 200);
                });
            });
            
            // More menu (filter sheet)
            const moreMenuBtn = document.getElementById('mobile-more-menu');
            const filterSheet = document.getElementById('mobile-filter-sheet');
            const sheetClose = document.getElementById('sheet-close');
            
            moreMenuBtn.addEventListener('click', () => {
                filterSheet.classList.add('active');
                initializeMobileCategories();
            });
            
            sheetClose.addEventListener('click', () => {
                filterSheet.classList.remove('active');
            });
            
            // Sheet swipe down to close
            let startY = 0;
            const sheetHandle = document.querySelector('.sheet-handle');
            
            sheetHandle.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
            });
            
            sheetHandle.addEventListener('touchmove', (e) => {
                const currentY = e.touches[0].clientY;
                const diff = currentY - startY;
                if (diff > 0) {
                    filterSheet.style.transform = `translateY(${diff}px)`;
                }
            });
            
            sheetHandle.addEventListener('touchend', (e) => {
                const currentY = e.changedTouches[0].clientY;
                const diff = currentY - startY;
                if (diff > 50) {
                    filterSheet.classList.remove('active');
                }
                filterSheet.style.transform = '';
            });
            
            // Initialize mobile categories
            function initializeMobileCategories() {
                const categoryList = document.getElementById('mobile-category-list');
                categoryList.innerHTML = '';
                
                const categories = ['admin', 'selling', 'research', 'product', 'hiring', 'other'];
                categories.forEach(cat => {
                    const item = document.createElement('label');
                    item.className = 'mobile-category-item';
                    item.innerHTML = `
                        <input type="checkbox" value="${cat}" ${activeCategories.has(cat) ? 'checked' : ''}>
                        <span>@${cat}</span>
                    `;
                    
                    const checkbox = item.querySelector('input');
                    checkbox.addEventListener('change', () => {
                        if (checkbox.checked) {
                            activeCategories.add(cat);
                        } else {
                            activeCategories.delete(cat);
                        }
                        updateDesktopCategoryChips();
                        renderTasks();
                    });
                    
                    categoryList.appendChild(item);
                });
            }
            
            // Sync mobile sort with desktop
            const mobileSortSelect = document.getElementById('mobile-sort-select');
            mobileSortSelect.value = currentSort;
            mobileSortSelect.addEventListener('change', (e) => {
                currentSort = e.target.value;
                document.getElementById('sort-select').value = currentSort;
                renderTasks();
            });
            
            // Update mobile filter counts
            function updateMobileFilterCounts() {
                document.getElementById('mobile-count-all').textContent = document.getElementById('count-all').textContent;
                document.getElementById('mobile-count-today').textContent = document.getElementById('count-today').textContent;
                document.getElementById('mobile-count-week').textContent = document.getElementById('count-week').textContent;
            }
            
            // Make working zone collapsible on mobile
            const workingZone = document.querySelector('.working-zone');
            if (workingZone) {
                workingZone.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768 && !e.target.closest('button')) {
                        workingZone.classList.toggle('collapsed');
                    }
                });
            }
            
            // Update counts on render
            const originalUpdateFilterCounts = updateFilterCounts;
            updateFilterCounts = function() {
                originalUpdateFilterCounts();
                updateMobileFilterCounts();
            };
            
            // Initial count update
            updateMobileFilterCounts();
        }
        
        // Update desktop category chips from mobile changes
        function updateDesktopCategoryChips() {
            const categoryChips = document.getElementById('category-chips');
            categoryChips.innerHTML = '';
            
            activeCategories.forEach(category => {
                const chip = document.createElement('div');
                chip.className = 'category-chip';
                chip.innerHTML = `
                    <span class="chip-label">@${category}</span>
                    <button class="remove-chip" title="Remove filter">√ó</button>
                `;
                
                chip.querySelector('.remove-chip').addEventListener('click', () => {
                    activeCategories.delete(category);
                    chip.remove();
                    renderTasks();
                });
                
                categoryChips.appendChild(chip);
            });
        }
        
        // Initialize mobile on load and resize
        initializeMobile();
        window.addEventListener('resize', () => {
            if (window.innerWidth <= 768) {
                initializeMobile();
            }
        });
    </script>

</body>
</html>